"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@paper-design+shaders@0.0.39";
exports.ids = ["vendor-chunks/@paper-design+shaders@0.0.39"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   getShaderColorFromString: () => (/* binding */ getShaderColorFromString)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nfunction getShaderColorFromString(colorString) {\n  if (Array.isArray(colorString)) {\n    if (colorString.length === 4) return colorString;\n    if (colorString.length === 3) return [...colorString, 1];\n    return fallbackColor;\n  }\n  if (typeof colorString !== \"string\") {\n    return fallbackColor;\n  }\n  let r, g, b, a = 1;\n  if (colorString.startsWith(\"#\")) {\n    [r, g, b, a] = hexToRgba(colorString);\n  } else if (colorString.startsWith(\"rgb\")) {\n    [r, g, b, a] = parseRgba(colorString);\n  } else if (colorString.startsWith(\"hsl\")) {\n    [r, g, b, a] = hslaToRgba(parseHsla(colorString));\n  } else {\n    console.error(\"Unsupported color format\", colorString);\n    return fallbackColor;\n  }\n  return [clamp(r, 0, 1), clamp(g, 0, 1), clamp(b, 0, 1), clamp(a, 0, 1)];\n}\nfunction hexToRgba(hex) {\n  hex = hex.replace(/^#/, \"\");\n  if (hex.length === 3) {\n    hex = hex.split(\"\").map((char) => char + char).join(\"\");\n  }\n  if (hex.length === 6) {\n    hex = hex + \"ff\";\n  }\n  const r = parseInt(hex.slice(0, 2), 16) / 255;\n  const g = parseInt(hex.slice(2, 4), 16) / 255;\n  const b = parseInt(hex.slice(4, 6), 16) / 255;\n  const a = parseInt(hex.slice(6, 8), 16) / 255;\n  return [r, g, b, a];\n}\nfunction parseRgba(rgba) {\n  const match = rgba.match(/^rgba?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\") / 255,\n    parseInt(match[2] ?? \"0\") / 255,\n    parseInt(match[3] ?? \"0\") / 255,\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction parseHsla(hsla) {\n  const match = hsla.match(/^hsla?\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*(?:,\\s*([0-9.]+))?\\s*\\)$/i);\n  if (!match) return [0, 0, 0, 1];\n  return [\n    parseInt(match[1] ?? \"0\"),\n    parseInt(match[2] ?? \"0\"),\n    parseInt(match[3] ?? \"0\"),\n    match[4] === void 0 ? 1 : parseFloat(match[4])\n  ];\n}\nfunction hslaToRgba(hsla) {\n  const [h, s, l, a] = hsla;\n  const hDecimal = h / 360;\n  const sDecimal = s / 100;\n  const lDecimal = l / 100;\n  let r, g, b;\n  if (s === 0) {\n    r = g = b = lDecimal;\n  } else {\n    const hue2rgb = (p2, q2, t) => {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;\n      if (t < 1 / 2) return q2;\n      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;\n      return p2;\n    };\n    const q = lDecimal < 0.5 ? lDecimal * (1 + sDecimal) : lDecimal + sDecimal - lDecimal * sDecimal;\n    const p = 2 * lDecimal - q;\n    r = hue2rgb(p, q, hDecimal + 1 / 3);\n    g = hue2rgb(p, q, hDecimal);\n    b = hue2rgb(p, q, hDecimal - 1 / 3);\n  }\n  return [r, g, b, a];\n}\nconst clamp = (n, min, max) => Math.min(Math.max(n, min), max);\nconst fallbackColor = [0, 0, 0, 1];\n\n//# sourceMappingURL=get-shader-color-from-string.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOS9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3QvZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGFubWlcXFVuaXZlcnNpdHkgU3R1ZmZcXENvZGluZyBQcm9qZWN0c1xcdHVyYm9yZWFkXFxhcHBzXFx3ZWJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBwYXBlci1kZXNpZ24rc2hhZGVyc0AwLjAuMzlcXG5vZGVfbW9kdWxlc1xcQHBhcGVyLWRlc2lnblxcc2hhZGVyc1xcZGlzdFxcZ2V0LXNoYWRlci1jb2xvci1mcm9tLXN0cmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuZnVuY3Rpb24gZ2V0U2hhZGVyQ29sb3JGcm9tU3RyaW5nKGNvbG9yU3RyaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbG9yU3RyaW5nKSkge1xuICAgIGlmIChjb2xvclN0cmluZy5sZW5ndGggPT09IDQpIHJldHVybiBjb2xvclN0cmluZztcbiAgICBpZiAoY29sb3JTdHJpbmcubGVuZ3RoID09PSAzKSByZXR1cm4gWy4uLmNvbG9yU3RyaW5nLCAxXTtcbiAgICByZXR1cm4gZmFsbGJhY2tDb2xvcjtcbiAgfVxuICBpZiAodHlwZW9mIGNvbG9yU3RyaW5nICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbGxiYWNrQ29sb3I7XG4gIH1cbiAgbGV0IHIsIGcsIGIsIGEgPSAxO1xuICBpZiAoY29sb3JTdHJpbmcuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoZXhUb1JnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJyZ2JcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBwYXJzZVJnYmEoY29sb3JTdHJpbmcpO1xuICB9IGVsc2UgaWYgKGNvbG9yU3RyaW5nLnN0YXJ0c1dpdGgoXCJoc2xcIikpIHtcbiAgICBbciwgZywgYiwgYV0gPSBoc2xhVG9SZ2JhKHBhcnNlSHNsYShjb2xvclN0cmluZykpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbnN1cHBvcnRlZCBjb2xvciBmb3JtYXRcIiwgY29sb3JTdHJpbmcpO1xuICAgIHJldHVybiBmYWxsYmFja0NvbG9yO1xuICB9XG4gIHJldHVybiBbY2xhbXAociwgMCwgMSksIGNsYW1wKGcsIDAsIDEpLCBjbGFtcChiLCAwLCAxKSwgY2xhbXAoYSwgMCwgMSldO1xufVxuZnVuY3Rpb24gaGV4VG9SZ2JhKGhleCkge1xuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCBcIlwiKTtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICBoZXggPSBoZXguc3BsaXQoXCJcIikubWFwKChjaGFyKSA9PiBjaGFyICsgY2hhcikuam9pbihcIlwiKTtcbiAgfVxuICBpZiAoaGV4Lmxlbmd0aCA9PT0gNikge1xuICAgIGhleCA9IGhleCArIFwiZmZcIjtcbiAgfVxuICBjb25zdCByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNikgLyAyNTU7XG4gIGNvbnN0IGcgPSBwYXJzZUludChoZXguc2xpY2UoMiwgNCksIDE2KSAvIDI1NTtcbiAgY29uc3QgYiA9IHBhcnNlSW50KGhleC5zbGljZSg0LCA2KSwgMTYpIC8gMjU1O1xuICBjb25zdCBhID0gcGFyc2VJbnQoaGV4LnNsaWNlKDYsIDgpLCAxNikgLyAyNTU7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5mdW5jdGlvbiBwYXJzZVJnYmEocmdiYSkge1xuICBjb25zdCBtYXRjaCA9IHJnYmEubWF0Y2goL15yZ2JhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspXFxzKig/OixcXHMqKFswLTkuXSspKT9cXHMqXFwpJC9pKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIFswLCAwLCAwLCAxXTtcbiAgcmV0dXJuIFtcbiAgICBwYXJzZUludChtYXRjaFsxXSA/PyBcIjBcIikgLyAyNTUsXG4gICAgcGFyc2VJbnQobWF0Y2hbMl0gPz8gXCIwXCIpIC8gMjU1LFxuICAgIHBhcnNlSW50KG1hdGNoWzNdID8/IFwiMFwiKSAvIDI1NSxcbiAgICBtYXRjaFs0XSA9PT0gdm9pZCAwID8gMSA6IHBhcnNlRmxvYXQobWF0Y2hbNF0pXG4gIF07XG59XG5mdW5jdGlvbiBwYXJzZUhzbGEoaHNsYSkge1xuICBjb25zdCBtYXRjaCA9IGhzbGEubWF0Y2goL15oc2xhP1xccypcXChcXHMqKFxcZCspXFxzKixcXHMqKFxcZCspJVxccyosXFxzKihcXGQrKSVcXHMqKD86LFxccyooWzAtOS5dKykpP1xccypcXCkkL2kpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gWzAsIDAsIDAsIDFdO1xuICByZXR1cm4gW1xuICAgIHBhcnNlSW50KG1hdGNoWzFdID8/IFwiMFwiKSxcbiAgICBwYXJzZUludChtYXRjaFsyXSA/PyBcIjBcIiksXG4gICAgcGFyc2VJbnQobWF0Y2hbM10gPz8gXCIwXCIpLFxuICAgIG1hdGNoWzRdID09PSB2b2lkIDAgPyAxIDogcGFyc2VGbG9hdChtYXRjaFs0XSlcbiAgXTtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoaHNsYSkge1xuICBjb25zdCBbaCwgcywgbCwgYV0gPSBoc2xhO1xuICBjb25zdCBoRGVjaW1hbCA9IGggLyAzNjA7XG4gIGNvbnN0IHNEZWNpbWFsID0gcyAvIDEwMDtcbiAgY29uc3QgbERlY2ltYWwgPSBsIC8gMTAwO1xuICBsZXQgciwgZywgYjtcbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsRGVjaW1hbDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBodWUycmdiID0gKHAyLCBxMiwgdCkgPT4ge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwMiArIChxMiAtIHAyKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHEyO1xuICAgICAgaWYgKHQgPCAyIC8gMykgcmV0dXJuIHAyICsgKHEyIC0gcDIpICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgcmV0dXJuIHAyO1xuICAgIH07XG4gICAgY29uc3QgcSA9IGxEZWNpbWFsIDwgMC41ID8gbERlY2ltYWwgKiAoMSArIHNEZWNpbWFsKSA6IGxEZWNpbWFsICsgc0RlY2ltYWwgLSBsRGVjaW1hbCAqIHNEZWNpbWFsO1xuICAgIGNvbnN0IHAgPSAyICogbERlY2ltYWwgLSBxO1xuICAgIHIgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsICsgMSAvIDMpO1xuICAgIGcgPSBodWUycmdiKHAsIHEsIGhEZWNpbWFsKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoRGVjaW1hbCAtIDEgLyAzKTtcbiAgfVxuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuY29uc3QgY2xhbXAgPSAobiwgbWluLCBtYXgpID0+IE1hdGgubWluKE1hdGgubWF4KG4sIG1pbiksIG1heCk7XG5jb25zdCBmYWxsYmFja0NvbG9yID0gWzAsIDAsIDAsIDFdO1xuZXhwb3J0IHtcbiAgY2xhbXAsXG4gIGdldFNoYWRlckNvbG9yRnJvbVN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1zaGFkZXItY29sb3ItZnJvbS1zdHJpbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/get-shader-color-from-string.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-mount.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-mount.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderMount: () => (/* binding */ ShaderMount),\n/* harmony export */   isPaperShaderElement: () => (/* binding */ isPaperShaderElement)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst DEFAULT_MAX_PIXEL_COUNT = 1920 * 1080 * 4;\nclass ShaderMount {\n  parentElement;\n  canvasElement;\n  gl;\n  program = null;\n  uniformLocations = {};\n  /** The fragment shader that we are using */\n  fragmentShader;\n  /** Stores the RAF for the render loop */\n  rafId = null;\n  /** Time of the last rendered frame */\n  lastRenderTime = 0;\n  /** Total time that we have played any animation, passed as a uniform to the shader for time-based VFX */\n  totalFrameTime = 0;\n  /** The current speed that we progress through animation time (multiplies by delta time every update). Allows negatives to play in reverse. If set to 0, rAF will stop entirely so static shaders have no recurring performance costs */\n  speed = 0;\n  /** Uniforms that are provided by the user for the specific shader being mounted (not including uniforms that this Mount adds, like time and resolution) */\n  providedUniforms;\n  /** Just a sanity check to make sure frames don't run after we're disposed */\n  hasBeenDisposed = false;\n  /** If the resolution of the canvas has changed since the last render */\n  resolutionChanged = true;\n  /** Store textures that are provided by the user */\n  textures = /* @__PURE__ */ new Map();\n  minPixelRatio;\n  maxPixelCount;\n  isSafari = isSafari();\n  uniformCache = {};\n  constructor(parentElement, fragmentShader, uniforms, webGlContextAttributes, speed = 0, frame = 0, minPixelRatio = 2, maxPixelCount = DEFAULT_MAX_PIXEL_COUNT) {\n    if (parentElement instanceof HTMLElement) {\n      this.parentElement = parentElement;\n    } else {\n      throw new Error(\"Paper Shaders: parent element must be an HTMLElement\");\n    }\n    if (!document.querySelector(\"style[data-paper-shader]\")) {\n      const styleElement = document.createElement(\"style\");\n      styleElement.innerHTML = defaultStyle;\n      styleElement.setAttribute(\"data-paper-shader\", \"\");\n      document.head.prepend(styleElement);\n    }\n    const canvasElement = document.createElement(\"canvas\");\n    this.canvasElement = canvasElement;\n    this.parentElement.prepend(canvasElement);\n    this.fragmentShader = fragmentShader;\n    this.providedUniforms = uniforms;\n    this.totalFrameTime = frame;\n    this.minPixelRatio = minPixelRatio;\n    this.maxPixelCount = maxPixelCount;\n    const gl = canvasElement.getContext(\"webgl2\", webGlContextAttributes);\n    if (!gl) {\n      throw new Error(\"Paper Shaders: WebGL is not supported in this browser\");\n    }\n    this.gl = gl;\n    this.initProgram();\n    this.setupPositionAttribute();\n    this.setupUniforms();\n    this.setUniformValues(this.providedUniforms);\n    this.setupResizeObserver();\n    this.setSpeed(speed);\n    this.parentElement.setAttribute(\"data-paper-shader\", \"\");\n    this.parentElement.paperShaderMount = this;\n  }\n  initProgram = () => {\n    const program = createProgram(this.gl, vertexShaderSource, this.fragmentShader);\n    if (!program) return;\n    this.program = program;\n  };\n  setupPositionAttribute = () => {\n    const positionAttributeLocation = this.gl.getAttribLocation(this.program, \"a_position\");\n    const positionBuffer = this.gl.createBuffer();\n    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, positionBuffer);\n    const positions = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];\n    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(positions), this.gl.STATIC_DRAW);\n    this.gl.enableVertexAttribArray(positionAttributeLocation);\n    this.gl.vertexAttribPointer(positionAttributeLocation, 2, this.gl.FLOAT, false, 0, 0);\n  };\n  setupUniforms = () => {\n    const uniformLocations = {\n      u_time: this.gl.getUniformLocation(this.program, \"u_time\"),\n      u_pixelRatio: this.gl.getUniformLocation(this.program, \"u_pixelRatio\"),\n      u_resolution: this.gl.getUniformLocation(this.program, \"u_resolution\")\n    };\n    Object.entries(this.providedUniforms).forEach(([key, value]) => {\n      uniformLocations[key] = this.gl.getUniformLocation(this.program, key);\n      if (value instanceof HTMLImageElement) {\n        const aspectRatioUniformName = `${key}_aspect_ratio`;\n        uniformLocations[aspectRatioUniformName] = this.gl.getUniformLocation(this.program, aspectRatioUniformName);\n      }\n    });\n    this.uniformLocations = uniformLocations;\n  };\n  /**\n   * The scale that we should render at.\n   * - Used to target 2x rendering even on 1x screens for better antialiasing\n   * - Prevents the virtual resolution from going beyond the maximum resolution\n   * - Accounts for the page zoom level so we render in physical device pixels rather than CSS pixels\n   */\n  renderScale = 1;\n  parentWidth = 0;\n  parentHeight = 0;\n  resizeObserver = null;\n  setupResizeObserver = () => {\n    this.resizeObserver = new ResizeObserver(([entry]) => {\n      if (entry?.borderBoxSize[0]) {\n        this.parentWidth = entry.borderBoxSize[0].inlineSize;\n        this.parentHeight = entry.borderBoxSize[0].blockSize;\n      }\n      this.handleResize();\n    });\n    this.resizeObserver.observe(this.parentElement);\n    visualViewport?.addEventListener(\"resize\", this.handleVisualViewportChange);\n    const rect = this.parentElement.getBoundingClientRect();\n    this.parentWidth = rect.width;\n    this.parentHeight = rect.height;\n    this.handleResize();\n  };\n  // Visual viewport resize handler, mainly used to react to browser zoom changes.\n  // Wait 2 frames to align with when the resize observer callback is done (in case it might follow):\n  // - Frame 1: a paint after the visual viewport resize\n  // - Frame 2: a paint after the resize observer has been handled, if it was ever triggered\n  //\n  // Both resize observer and visual viewport will react to classic browser zoom changes,\n  // so we dedupe the callbacks, but pinch zoom only triggers the visual viewport handler.\n  resizeRafId = null;\n  handleVisualViewportChange = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    this.resizeRafId = requestAnimationFrame(() => {\n      this.resizeRafId = requestAnimationFrame(() => {\n        this.handleResize();\n      });\n    });\n  };\n  /** Resize handler for when the container div changes size or the max pixel count changes and we want to resize our canvas to match */\n  handleResize = () => {\n    if (this.resizeRafId !== null) {\n      cancelAnimationFrame(this.resizeRafId);\n    }\n    const pinchZoom = visualViewport?.scale ?? 1;\n    const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;\n    const innerWidth = visualViewport ? visualViewport.scale * visualViewport.width + scrollbarWidth : window.innerWidth;\n    const classicZoom = Math.round(1e4 * window.outerWidth / innerWidth) / 1e4;\n    const realPixelRatio = this.isSafari ? devicePixelRatio : devicePixelRatio / classicZoom;\n    const targetPixelRatio = Math.max(realPixelRatio, this.minPixelRatio);\n    const targetRenderScale = targetPixelRatio * classicZoom * pinchZoom;\n    const targetPixelWidth = this.parentWidth * targetRenderScale;\n    const targetPixelHeight = this.parentHeight * targetRenderScale;\n    const maxPixelCountHeadroom = Math.sqrt(this.maxPixelCount) / Math.sqrt(targetPixelWidth * targetPixelHeight);\n    const newRenderScale = targetRenderScale * Math.min(1, maxPixelCountHeadroom);\n    const newWidth = Math.round(this.parentWidth * newRenderScale);\n    const newHeight = Math.round(this.parentHeight * newRenderScale);\n    if (this.canvasElement.width !== newWidth || this.canvasElement.height !== newHeight || this.renderScale !== newRenderScale) {\n      this.renderScale = newRenderScale;\n      this.canvasElement.width = newWidth;\n      this.canvasElement.height = newHeight;\n      this.resolutionChanged = true;\n      this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height);\n      this.render(performance.now());\n    }\n  };\n  render = (currentTime) => {\n    if (this.hasBeenDisposed) return;\n    if (this.program === null) {\n      console.warn(\"Tried to render before program or gl was initialized\");\n      return;\n    }\n    const dt = currentTime - this.lastRenderTime;\n    this.lastRenderTime = currentTime;\n    if (this.speed !== 0) {\n      this.totalFrameTime += dt * this.speed;\n    }\n    this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n    this.gl.useProgram(this.program);\n    this.gl.uniform1f(this.uniformLocations.u_time, this.totalFrameTime * 1e-3);\n    if (this.resolutionChanged) {\n      this.gl.uniform2f(this.uniformLocations.u_resolution, this.gl.canvas.width, this.gl.canvas.height);\n      this.gl.uniform1f(this.uniformLocations.u_pixelRatio, this.renderScale);\n      this.resolutionChanged = false;\n    }\n    this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);\n    if (this.speed !== 0) {\n      this.requestRender();\n    } else {\n      this.rafId = null;\n    }\n  };\n  requestRender = () => {\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n    }\n    this.rafId = requestAnimationFrame(this.render);\n  };\n  /** Creates a texture from an image and sets it into a uniform value */\n  setTextureUniform = (uniformName, image) => {\n    if (!image.complete || image.naturalWidth === 0) {\n      throw new Error(`Paper Shaders: image for uniform ${uniformName} must be fully loaded`);\n    }\n    const existingTexture = this.textures.get(uniformName);\n    if (existingTexture) {\n      this.gl.deleteTexture(existingTexture);\n    }\n    const texture = this.gl.createTexture();\n    this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.REPEAT);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n    this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, image);\n    const error = this.gl.getError();\n    if (error !== this.gl.NO_ERROR || texture === null) {\n      console.error(\"Paper Shaders: WebGL error when uploading texture:\", error);\n      return;\n    }\n    this.textures.set(uniformName, texture);\n    const location = this.uniformLocations[uniformName];\n    if (location) {\n      const textureUnit = this.textures.size - 1;\n      this.gl.useProgram(this.program);\n      this.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n      this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n      this.gl.uniform1i(location, textureUnit);\n      const aspectRatioUniformName = `${uniformName}_aspect_ratio`;\n      const aspectRatioLocation = this.uniformLocations[aspectRatioUniformName];\n      if (aspectRatioLocation) {\n        const aspectRatio = image.naturalWidth / image.naturalHeight;\n        this.gl.uniform1f(aspectRatioLocation, aspectRatio);\n      }\n    }\n  };\n  /** Utility: recursive equality test for all the uniforms */\n  areUniformValuesEqual = (a, b) => {\n    if (a === b) return true;\n    if (Array.isArray(a) && Array.isArray(b) && a.length === b.length) {\n      return a.every((val, i) => this.areUniformValuesEqual(val, b[i]));\n    }\n    return false;\n  };\n  /** Sets the provided uniform values into the WebGL program, can be a partial list of uniforms that have changed */\n  setUniformValues = (updatedUniforms) => {\n    this.gl.useProgram(this.program);\n    Object.entries(updatedUniforms).forEach(([key, value]) => {\n      if (this.areUniformValuesEqual(this.uniformCache[key], value)) return;\n      const location = this.uniformLocations[key];\n      if (!location) {\n        console.warn(`Uniform location for ${key} not found`);\n        return;\n      }\n      if (value instanceof HTMLImageElement) {\n        this.setTextureUniform(key, value);\n      } else if (Array.isArray(value)) {\n        let flatArray = null;\n        let valueLength = null;\n        if (value[0] !== void 0 && Array.isArray(value[0])) {\n          const firstChildLength = value[0].length;\n          if (value.every((arr) => arr.length === firstChildLength)) {\n            flatArray = value.flat();\n            valueLength = firstChildLength;\n          } else {\n            console.warn(`All child arrays must be the same length for ${key}`);\n            return;\n          }\n        } else {\n          flatArray = value;\n          valueLength = flatArray.length;\n        }\n        switch (valueLength) {\n          case 2:\n            this.gl.uniform2fv(location, flatArray);\n            break;\n          case 3:\n            this.gl.uniform3fv(location, flatArray);\n            break;\n          case 4:\n            this.gl.uniform4fv(location, flatArray);\n            break;\n          case 9:\n            this.gl.uniformMatrix3fv(location, false, flatArray);\n            break;\n          case 16:\n            this.gl.uniformMatrix4fv(location, false, flatArray);\n            break;\n          default:\n            console.warn(`Unsupported uniform array length: ${valueLength}`);\n        }\n      } else if (typeof value === \"number\") {\n        this.gl.uniform1f(location, value);\n      } else if (typeof value === \"boolean\") {\n        this.gl.uniform1i(location, value ? 1 : 0);\n      } else {\n        console.warn(`Unsupported uniform type for ${key}: ${typeof value}`);\n      }\n      this.uniformCache[key] = value;\n    });\n  };\n  /** Gets the current total animation time from 0ms */\n  getCurrentFrameTime = () => {\n    return this.totalFrameTime;\n  };\n  /** Set a frame to get a deterministic result, frames are literally just milliseconds from zero since the animation started */\n  setFrame = (newFrame) => {\n    this.totalFrameTime = newFrame;\n    this.lastRenderTime = performance.now();\n    this.render(performance.now());\n  };\n  /** Set an animation speed (or 0 to stop animation) */\n  setSpeed = (newSpeed = 1) => {\n    this.speed = newSpeed;\n    if (this.rafId === null && newSpeed !== 0) {\n      this.lastRenderTime = performance.now();\n      this.rafId = requestAnimationFrame(this.render);\n    }\n    if (this.rafId !== null && newSpeed === 0) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n  };\n  /** Set the maximum pixel count for the shader, this will limit the number of pixels that will be rendered */\n  setMaxPixelCount = (newMaxPixelCount = DEFAULT_MAX_PIXEL_COUNT) => {\n    this.maxPixelCount = newMaxPixelCount;\n    this.handleResize();\n  };\n  /** Set the minimum pixel ratio for the shader */\n  setMinPixelRatio = (newMinPixelRatio = 2) => {\n    this.minPixelRatio = newMinPixelRatio;\n    this.handleResize();\n  };\n  /** Update the uniforms that are provided by the outside shader, can be a partial set with only the uniforms that have changed */\n  setUniforms = (newUniforms) => {\n    this.setUniformValues(newUniforms);\n    this.providedUniforms = { ...this.providedUniforms, ...newUniforms };\n    this.render(performance.now());\n  };\n  /** Dispose of the shader mount, cleaning up all of the WebGL resources */\n  dispose = () => {\n    this.hasBeenDisposed = true;\n    if (this.rafId !== null) {\n      cancelAnimationFrame(this.rafId);\n      this.rafId = null;\n    }\n    if (this.gl && this.program) {\n      this.textures.forEach((texture) => {\n        this.gl.deleteTexture(texture);\n      });\n      this.textures.clear();\n      this.gl.deleteProgram(this.program);\n      this.program = null;\n      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);\n      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, null);\n      this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n      this.gl.getError();\n    }\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      this.resizeObserver = null;\n    }\n    visualViewport?.removeEventListener(\"resize\", this.handleVisualViewportChange);\n    this.uniformLocations = {};\n    this.parentElement.paperShaderMount = void 0;\n  };\n}\nconst vertexShaderSource = `#version 300 es\nprecision mediump float;\n\nlayout(location = 0) in vec4 a_position;\n\nuniform vec2 u_resolution;\nuniform float u_pixelRatio;\n\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;\n\nuniform float u_pxSize;\n\nout vec2 v_objectUV;\nout vec2 v_objectBoxSize;\nout vec2 v_objectHelperBox;\n\nout vec2 v_responsiveUV;\nout vec2 v_responsiveBoxSize;\nout vec2 v_responsiveHelperBox;\nout vec2 v_responsiveBoxGivenSize;\n\nout vec2 v_patternUV;\nout vec2 v_patternBoxSize;\nout vec2 v_patternHelperBox;\n\n// #define ADD_HELPERS\n\nvec3 getBoxSize(float boxRatio, vec2 givenBoxSize, vec2 maxBoxSize) {\n  vec2 box = vec2(0.);\n  // fit = none\n  box.x = boxRatio * min(givenBoxSize.x / boxRatio, givenBoxSize.y);\n  float noFitBoxWidth = box.x;\n  if (u_fit == 1.) { // fit = contain\n    box.x = boxRatio * min(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  } else if (u_fit == 2.) { // fit = cover\n    box.x = boxRatio * max(maxBoxSize[0] / boxRatio, maxBoxSize[1]);\n  }\n  box.y = box.x / boxRatio;\n  return vec3(box, noFitBoxWidth);\n}\n\nvoid main() {\n  gl_Position = a_position;\n\n  vec2 uv = gl_Position.xy * .5;\n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n\n  // ===================================================\n  // Sizing api for graphic objects with fixed ratio\n  // (currently supports only ratio = 1)\n\n  float fixedRatio = 1.;\n  vec2 fixedRatioBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n\n  v_objectBoxSize = getBoxSize(fixedRatio, fixedRatioBoxGivenSize, maxBoxSize).xy;\n  vec2 objectWorldScale = u_resolution.xy / v_objectBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_objectHelperBox = uv;\n    v_objectHelperBox *= objectWorldScale;\n    v_objectHelperBox += boxOrigin * (objectWorldScale - 1.);\n  #endif\n\n  v_objectUV = uv;\n  v_objectUV *= objectWorldScale;\n  v_objectUV += boxOrigin * (objectWorldScale - 1.);\n  v_objectUV += graphicOffset;\n  v_objectUV /= u_scale;\n  v_objectUV = graphicRotation * v_objectUV;\n\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for graphic objects with either givenBoxSize ratio or canvas ratio.\n  // Full-screen mode available with u_worldWidth = u_worldHeight = 0\n\n  v_responsiveBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  float responsiveRatio = v_responsiveBoxGivenSize.x / v_responsiveBoxGivenSize.y;\n  v_responsiveBoxSize = getBoxSize(responsiveRatio, v_responsiveBoxGivenSize, maxBoxSize).xy;\n  vec2 responsiveBoxScale = u_resolution.xy / v_responsiveBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_responsiveHelperBox = uv;\n    v_responsiveHelperBox *= responsiveBoxScale;\n    v_responsiveHelperBox += boxOrigin * (responsiveBoxScale - 1.);\n  #endif\n\n  v_responsiveUV = uv;\n  v_responsiveUV *= responsiveBoxScale;\n  v_responsiveUV += boxOrigin * (responsiveBoxScale - 1.);\n  v_responsiveUV += graphicOffset;\n  v_responsiveUV /= u_scale;\n  v_responsiveUV.x *= responsiveRatio;\n  v_responsiveUV = graphicRotation * v_responsiveUV;\n  v_responsiveUV.x /= responsiveRatio;\n\n  // ===================================================\n\n\n  // ===================================================\n  // Sizing api for patterns\n  // (treating graphics as a image u_worldWidth x u_worldHeight size)\n\n  float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n  vec2 patternBoxGivenSize = vec2(\n    (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n    (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n  );\n  patternBoxRatio = patternBoxGivenSize.x / patternBoxGivenSize.y;\n\n  vec3 boxSizeData = getBoxSize(patternBoxRatio, patternBoxGivenSize, maxBoxSize);\n  v_patternBoxSize = boxSizeData.xy;\n  float patternBoxNoFitBoxWidth = boxSizeData.z;\n  vec2 patternBoxScale = u_resolution.xy / v_patternBoxSize;\n\n  #ifdef ADD_HELPERS\n    v_patternHelperBox = uv;\n    v_patternHelperBox *= patternBoxScale;\n    v_patternHelperBox += boxOrigin * (patternBoxScale - 1.);\n  #endif\n\n  v_patternUV = uv;\n  v_patternUV += graphicOffset / patternBoxScale;\n  v_patternUV += boxOrigin;\n  v_patternUV -= boxOrigin / patternBoxScale;\n  v_patternUV *= u_resolution.xy;\n  v_patternUV /= u_pixelRatio;\n  if (u_fit > 0.) {\n    v_patternUV *= (patternBoxNoFitBoxWidth / v_patternBoxSize.x);\n  }\n  v_patternUV /= u_scale;\n  v_patternUV = graphicRotation * v_patternUV;\n  v_patternUV += boxOrigin / patternBoxScale;\n  v_patternUV -= boxOrigin;\n  v_patternUV += .5;\n\n  // ===================================================\n\n}`;\nfunction createShader(gl, type, source) {\n  const shader = gl.createShader(type);\n  if (!shader) return null;\n  gl.shaderSource(shader, source);\n  gl.compileShader(shader);\n  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n    console.error(\"An error occurred compiling the shaders: \" + gl.getShaderInfoLog(shader));\n    gl.deleteShader(shader);\n    return null;\n  }\n  return shader;\n}\nfunction createProgram(gl, vertexShaderSource2, fragmentShaderSource) {\n  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource2);\n  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);\n  if (!vertexShader || !fragmentShader) return null;\n  const program = gl.createProgram();\n  if (!program) return null;\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n  gl.linkProgram(program);\n  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n    console.error(\"Unable to initialize the shader program: \" + gl.getProgramInfoLog(program));\n    gl.deleteProgram(program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n    return null;\n  }\n  gl.detachShader(program, vertexShader);\n  gl.detachShader(program, fragmentShader);\n  gl.deleteShader(vertexShader);\n  gl.deleteShader(fragmentShader);\n  return program;\n}\nconst defaultStyle = `@layer paper-shaders {\n  :where([data-paper-shader]) {\n    isolation: isolate;\n    position: relative;\n\n    & canvas {\n      contain: strict;\n      display: block;\n      position: absolute;\n      inset: 0;\n      z-index: -1;\n      width: 100%;\n      height: 100%;\n      border-radius: inherit;\n    }\n  }\n}`;\nfunction isPaperShaderElement(element) {\n  return \"paperShaderMount\" in element;\n}\nfunction isSafari() {\n  const ua = navigator.userAgent.toLowerCase();\n  return ua.includes(\"safari\") && !ua.includes(\"chrome\") && !ua.includes(\"android\");\n}\n\n//# sourceMappingURL=shader-mount.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOS9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLW1vdW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsYUFBYTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1oseUVBQXlFLElBQUk7QUFDN0U7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IscURBQXFELElBQUksSUFBSSxhQUFhO0FBQzFFO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxJQUFJLHdCQUF3QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJRTtBQUNGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhhbm1pXFxVbml2ZXJzaXR5IFN0dWZmXFxDb2RpbmcgUHJvamVjdHNcXHR1cmJvcmVhZFxcYXBwc1xcd2ViXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAcGFwZXItZGVzaWduK3NoYWRlcnNAMC4wLjM5XFxub2RlX21vZHVsZXNcXEBwYXBlci1kZXNpZ25cXHNoYWRlcnNcXGRpc3RcXHNoYWRlci1tb3VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3QgREVGQVVMVF9NQVhfUElYRUxfQ09VTlQgPSAxOTIwICogMTA4MCAqIDQ7XG5jbGFzcyBTaGFkZXJNb3VudCB7XG4gIHBhcmVudEVsZW1lbnQ7XG4gIGNhbnZhc0VsZW1lbnQ7XG4gIGdsO1xuICBwcm9ncmFtID0gbnVsbDtcbiAgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAvKiogVGhlIGZyYWdtZW50IHNoYWRlciB0aGF0IHdlIGFyZSB1c2luZyAqL1xuICBmcmFnbWVudFNoYWRlcjtcbiAgLyoqIFN0b3JlcyB0aGUgUkFGIGZvciB0aGUgcmVuZGVyIGxvb3AgKi9cbiAgcmFmSWQgPSBudWxsO1xuICAvKiogVGltZSBvZiB0aGUgbGFzdCByZW5kZXJlZCBmcmFtZSAqL1xuICBsYXN0UmVuZGVyVGltZSA9IDA7XG4gIC8qKiBUb3RhbCB0aW1lIHRoYXQgd2UgaGF2ZSBwbGF5ZWQgYW55IGFuaW1hdGlvbiwgcGFzc2VkIGFzIGEgdW5pZm9ybSB0byB0aGUgc2hhZGVyIGZvciB0aW1lLWJhc2VkIFZGWCAqL1xuICB0b3RhbEZyYW1lVGltZSA9IDA7XG4gIC8qKiBUaGUgY3VycmVudCBzcGVlZCB0aGF0IHdlIHByb2dyZXNzIHRocm91Z2ggYW5pbWF0aW9uIHRpbWUgKG11bHRpcGxpZXMgYnkgZGVsdGEgdGltZSBldmVyeSB1cGRhdGUpLiBBbGxvd3MgbmVnYXRpdmVzIHRvIHBsYXkgaW4gcmV2ZXJzZS4gSWYgc2V0IHRvIDAsIHJBRiB3aWxsIHN0b3AgZW50aXJlbHkgc28gc3RhdGljIHNoYWRlcnMgaGF2ZSBubyByZWN1cnJpbmcgcGVyZm9ybWFuY2UgY29zdHMgKi9cbiAgc3BlZWQgPSAwO1xuICAvKiogVW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIHVzZXIgZm9yIHRoZSBzcGVjaWZpYyBzaGFkZXIgYmVpbmcgbW91bnRlZCAobm90IGluY2x1ZGluZyB1bmlmb3JtcyB0aGF0IHRoaXMgTW91bnQgYWRkcywgbGlrZSB0aW1lIGFuZCByZXNvbHV0aW9uKSAqL1xuICBwcm92aWRlZFVuaWZvcm1zO1xuICAvKiogSnVzdCBhIHNhbml0eSBjaGVjayB0byBtYWtlIHN1cmUgZnJhbWVzIGRvbid0IHJ1biBhZnRlciB3ZSdyZSBkaXNwb3NlZCAqL1xuICBoYXNCZWVuRGlzcG9zZWQgPSBmYWxzZTtcbiAgLyoqIElmIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgcmVuZGVyICovXG4gIHJlc29sdXRpb25DaGFuZ2VkID0gdHJ1ZTtcbiAgLyoqIFN0b3JlIHRleHR1cmVzIHRoYXQgYXJlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyICovXG4gIHRleHR1cmVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgbWluUGl4ZWxSYXRpbztcbiAgbWF4UGl4ZWxDb3VudDtcbiAgaXNTYWZhcmkgPSBpc1NhZmFyaSgpO1xuICB1bmlmb3JtQ2FjaGUgPSB7fTtcbiAgY29uc3RydWN0b3IocGFyZW50RWxlbWVudCwgZnJhZ21lbnRTaGFkZXIsIHVuaWZvcm1zLCB3ZWJHbENvbnRleHRBdHRyaWJ1dGVzLCBzcGVlZCA9IDAsIGZyYW1lID0gMCwgbWluUGl4ZWxSYXRpbyA9IDIsIG1heFBpeGVsQ291bnQgPSBERUZBVUxUX01BWF9QSVhFTF9DT1VOVCkge1xuICAgIGlmIChwYXJlbnRFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucGFyZW50RWxlbWVudCA9IHBhcmVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IHBhcmVudCBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnRcIik7XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInN0eWxlW2RhdGEtcGFwZXItc2hhZGVyXVwiKSkge1xuICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgc3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGRlZmF1bHRTdHlsZTtcbiAgICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICAgIGRvY3VtZW50LmhlYWQucHJlcGVuZChzdHlsZUVsZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhc0VsZW1lbnQgPSBjYW52YXNFbGVtZW50O1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5wcmVwZW5kKGNhbnZhc0VsZW1lbnQpO1xuICAgIHRoaXMuZnJhZ21lbnRTaGFkZXIgPSBmcmFnbWVudFNoYWRlcjtcbiAgICB0aGlzLnByb3ZpZGVkVW5pZm9ybXMgPSB1bmlmb3JtcztcbiAgICB0aGlzLnRvdGFsRnJhbWVUaW1lID0gZnJhbWU7XG4gICAgdGhpcy5taW5QaXhlbFJhdGlvID0gbWluUGl4ZWxSYXRpbztcbiAgICB0aGlzLm1heFBpeGVsQ291bnQgPSBtYXhQaXhlbENvdW50O1xuICAgIGNvbnN0IGdsID0gY2FudmFzRWxlbWVudC5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIHdlYkdsQ29udGV4dEF0dHJpYnV0ZXMpO1xuICAgIGlmICghZ2wpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcGVyIFNoYWRlcnM6IFdlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuICAgIH1cbiAgICB0aGlzLmdsID0gZ2w7XG4gICAgdGhpcy5pbml0UHJvZ3JhbSgpO1xuICAgIHRoaXMuc2V0dXBQb3NpdGlvbkF0dHJpYnV0ZSgpO1xuICAgIHRoaXMuc2V0dXBVbmlmb3JtcygpO1xuICAgIHRoaXMuc2V0VW5pZm9ybVZhbHVlcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpO1xuICAgIHRoaXMuc2V0dXBSZXNpemVPYnNlcnZlcigpO1xuICAgIHRoaXMuc2V0U3BlZWQoc3BlZWQpO1xuICAgIHRoaXMucGFyZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhcGVyLXNoYWRlclwiLCBcIlwiKTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucGFwZXJTaGFkZXJNb3VudCA9IHRoaXM7XG4gIH1cbiAgaW5pdFByb2dyYW0gPSAoKSA9PiB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0odGhpcy5nbCwgdmVydGV4U2hhZGVyU291cmNlLCB0aGlzLmZyYWdtZW50U2hhZGVyKTtcbiAgICBpZiAoIXByb2dyYW0pIHJldHVybjtcbiAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICB9O1xuICBzZXR1cFBvc2l0aW9uQXR0cmlidXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24gPSB0aGlzLmdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgXCJhX3Bvc2l0aW9uXCIpO1xuICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG4gICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHBvc2l0aW9ucyksIHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25BdHRyaWJ1dGVMb2NhdGlvbik7XG4gICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uQXR0cmlidXRlTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgfTtcbiAgc2V0dXBVbmlmb3JtcyA9ICgpID0+IHtcbiAgICBjb25zdCB1bmlmb3JtTG9jYXRpb25zID0ge1xuICAgICAgdV90aW1lOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV90aW1lXCIpLFxuICAgICAgdV9waXhlbFJhdGlvOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9waXhlbFJhdGlvXCIpLFxuICAgICAgdV9yZXNvbHV0aW9uOiB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpXG4gICAgfTtcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLnByb3ZpZGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgdW5pZm9ybUxvY2F0aW9uc1trZXldID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBrZXkpO1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7a2V5fV9hc3BlY3RfcmF0aW9gO1xuICAgICAgICB1bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB1bmlmb3JtTG9jYXRpb25zO1xuICB9O1xuICAvKipcbiAgICogVGhlIHNjYWxlIHRoYXQgd2Ugc2hvdWxkIHJlbmRlciBhdC5cbiAgICogLSBVc2VkIHRvIHRhcmdldCAyeCByZW5kZXJpbmcgZXZlbiBvbiAxeCBzY3JlZW5zIGZvciBiZXR0ZXIgYW50aWFsaWFzaW5nXG4gICAqIC0gUHJldmVudHMgdGhlIHZpcnR1YWwgcmVzb2x1dGlvbiBmcm9tIGdvaW5nIGJleW9uZCB0aGUgbWF4aW11bSByZXNvbHV0aW9uXG4gICAqIC0gQWNjb3VudHMgZm9yIHRoZSBwYWdlIHpvb20gbGV2ZWwgc28gd2UgcmVuZGVyIGluIHBoeXNpY2FsIGRldmljZSBwaXhlbHMgcmF0aGVyIHRoYW4gQ1NTIHBpeGVsc1xuICAgKi9cbiAgcmVuZGVyU2NhbGUgPSAxO1xuICBwYXJlbnRXaWR0aCA9IDA7XG4gIHBhcmVudEhlaWdodCA9IDA7XG4gIHJlc2l6ZU9ic2VydmVyID0gbnVsbDtcbiAgc2V0dXBSZXNpemVPYnNlcnZlciA9ICgpID0+IHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChbZW50cnldKSA9PiB7XG4gICAgICBpZiAoZW50cnk/LmJvcmRlckJveFNpemVbMF0pIHtcbiAgICAgICAgdGhpcy5wYXJlbnRXaWR0aCA9IGVudHJ5LmJvcmRlckJveFNpemVbMF0uaW5saW5lU2l6ZTtcbiAgICAgICAgdGhpcy5wYXJlbnRIZWlnaHQgPSBlbnRyeS5ib3JkZXJCb3hTaXplWzBdLmJsb2NrU2l6ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gICAgfSk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucGFyZW50RWxlbWVudCk7XG4gICAgdmlzdWFsVmlld3BvcnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5oYW5kbGVWaXN1YWxWaWV3cG9ydENoYW5nZSk7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLnBhcmVudFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICB0aGlzLnBhcmVudEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8vIFZpc3VhbCB2aWV3cG9ydCByZXNpemUgaGFuZGxlciwgbWFpbmx5IHVzZWQgdG8gcmVhY3QgdG8gYnJvd3NlciB6b29tIGNoYW5nZXMuXG4gIC8vIFdhaXQgMiBmcmFtZXMgdG8gYWxpZ24gd2l0aCB3aGVuIHRoZSByZXNpemUgb2JzZXJ2ZXIgY2FsbGJhY2sgaXMgZG9uZSAoaW4gY2FzZSBpdCBtaWdodCBmb2xsb3cpOlxuICAvLyAtIEZyYW1lIDE6IGEgcGFpbnQgYWZ0ZXIgdGhlIHZpc3VhbCB2aWV3cG9ydCByZXNpemVcbiAgLy8gLSBGcmFtZSAyOiBhIHBhaW50IGFmdGVyIHRoZSByZXNpemUgb2JzZXJ2ZXIgaGFzIGJlZW4gaGFuZGxlZCwgaWYgaXQgd2FzIGV2ZXIgdHJpZ2dlcmVkXG4gIC8vXG4gIC8vIEJvdGggcmVzaXplIG9ic2VydmVyIGFuZCB2aXN1YWwgdmlld3BvcnQgd2lsbCByZWFjdCB0byBjbGFzc2ljIGJyb3dzZXIgem9vbSBjaGFuZ2VzLFxuICAvLyBzbyB3ZSBkZWR1cGUgdGhlIGNhbGxiYWNrcywgYnV0IHBpbmNoIHpvb20gb25seSB0cmlnZ2VycyB0aGUgdmlzdWFsIHZpZXdwb3J0IGhhbmRsZXIuXG4gIHJlc2l6ZVJhZklkID0gbnVsbDtcbiAgaGFuZGxlVmlzdWFsVmlld3BvcnRDaGFuZ2UgPSAoKSA9PiB7XG4gICAgaWYgKHRoaXMucmVzaXplUmFmSWQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVzaXplUmFmSWQpO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZVJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMucmVzaXplUmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIC8qKiBSZXNpemUgaGFuZGxlciBmb3Igd2hlbiB0aGUgY29udGFpbmVyIGRpdiBjaGFuZ2VzIHNpemUgb3IgdGhlIG1heCBwaXhlbCBjb3VudCBjaGFuZ2VzIGFuZCB3ZSB3YW50IHRvIHJlc2l6ZSBvdXIgY2FudmFzIHRvIG1hdGNoICovXG4gIGhhbmRsZVJlc2l6ZSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yZXNpemVSYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVSYWZJZCk7XG4gICAgfVxuICAgIGNvbnN0IHBpbmNoWm9vbSA9IHZpc3VhbFZpZXdwb3J0Py5zY2FsZSA/PyAxO1xuICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gd2luZG93LmlubmVyV2lkdGggLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgaW5uZXJXaWR0aCA9IHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQuc2NhbGUgKiB2aXN1YWxWaWV3cG9ydC53aWR0aCArIHNjcm9sbGJhcldpZHRoIDogd2luZG93LmlubmVyV2lkdGg7XG4gICAgY29uc3QgY2xhc3NpY1pvb20gPSBNYXRoLnJvdW5kKDFlNCAqIHdpbmRvdy5vdXRlcldpZHRoIC8gaW5uZXJXaWR0aCkgLyAxZTQ7XG4gICAgY29uc3QgcmVhbFBpeGVsUmF0aW8gPSB0aGlzLmlzU2FmYXJpID8gZGV2aWNlUGl4ZWxSYXRpbyA6IGRldmljZVBpeGVsUmF0aW8gLyBjbGFzc2ljWm9vbTtcbiAgICBjb25zdCB0YXJnZXRQaXhlbFJhdGlvID0gTWF0aC5tYXgocmVhbFBpeGVsUmF0aW8sIHRoaXMubWluUGl4ZWxSYXRpbyk7XG4gICAgY29uc3QgdGFyZ2V0UmVuZGVyU2NhbGUgPSB0YXJnZXRQaXhlbFJhdGlvICogY2xhc3NpY1pvb20gKiBwaW5jaFpvb207XG4gICAgY29uc3QgdGFyZ2V0UGl4ZWxXaWR0aCA9IHRoaXMucGFyZW50V2lkdGggKiB0YXJnZXRSZW5kZXJTY2FsZTtcbiAgICBjb25zdCB0YXJnZXRQaXhlbEhlaWdodCA9IHRoaXMucGFyZW50SGVpZ2h0ICogdGFyZ2V0UmVuZGVyU2NhbGU7XG4gICAgY29uc3QgbWF4UGl4ZWxDb3VudEhlYWRyb29tID0gTWF0aC5zcXJ0KHRoaXMubWF4UGl4ZWxDb3VudCkgLyBNYXRoLnNxcnQodGFyZ2V0UGl4ZWxXaWR0aCAqIHRhcmdldFBpeGVsSGVpZ2h0KTtcbiAgICBjb25zdCBuZXdSZW5kZXJTY2FsZSA9IHRhcmdldFJlbmRlclNjYWxlICogTWF0aC5taW4oMSwgbWF4UGl4ZWxDb3VudEhlYWRyb29tKTtcbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgucm91bmQodGhpcy5wYXJlbnRXaWR0aCAqIG5ld1JlbmRlclNjYWxlKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMucGFyZW50SGVpZ2h0ICogbmV3UmVuZGVyU2NhbGUpO1xuICAgIGlmICh0aGlzLmNhbnZhc0VsZW1lbnQud2lkdGggIT09IG5ld1dpZHRoIHx8IHRoaXMuY2FudmFzRWxlbWVudC5oZWlnaHQgIT09IG5ld0hlaWdodCB8fCB0aGlzLnJlbmRlclNjYWxlICE9PSBuZXdSZW5kZXJTY2FsZSkge1xuICAgICAgdGhpcy5yZW5kZXJTY2FsZSA9IG5ld1JlbmRlclNjYWxlO1xuICAgICAgdGhpcy5jYW52YXNFbGVtZW50LndpZHRoID0gbmV3V2lkdGg7XG4gICAgICB0aGlzLmNhbnZhc0VsZW1lbnQuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgdGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZ2wuY2FudmFzLndpZHRoLCB0aGlzLmdsLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdGhpcy5yZW5kZXIocGVyZm9ybWFuY2Uubm93KCkpO1xuICAgIH1cbiAgfTtcbiAgcmVuZGVyID0gKGN1cnJlbnRUaW1lKSA9PiB7XG4gICAgaWYgKHRoaXMuaGFzQmVlbkRpc3Bvc2VkKSByZXR1cm47XG4gICAgaWYgKHRoaXMucHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gcmVuZGVyIGJlZm9yZSBwcm9ncmFtIG9yIGdsIHdhcyBpbml0aWFsaXplZFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZHQgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFJlbmRlclRpbWU7XG4gICAgdGhpcy5sYXN0UmVuZGVyVGltZSA9IGN1cnJlbnRUaW1lO1xuICAgIGlmICh0aGlzLnNwZWVkICE9PSAwKSB7XG4gICAgICB0aGlzLnRvdGFsRnJhbWVUaW1lICs9IGR0ICogdGhpcy5zcGVlZDtcbiAgICB9XG4gICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIHRoaXMuZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgIHRoaXMuZ2wudW5pZm9ybTFmKHRoaXMudW5pZm9ybUxvY2F0aW9ucy51X3RpbWUsIHRoaXMudG90YWxGcmFtZVRpbWUgKiAxZS0zKTtcbiAgICBpZiAodGhpcy5yZXNvbHV0aW9uQ2hhbmdlZCkge1xuICAgICAgdGhpcy5nbC51bmlmb3JtMmYodGhpcy51bmlmb3JtTG9jYXRpb25zLnVfcmVzb2x1dGlvbiwgdGhpcy5nbC5jYW52YXMud2lkdGgsIHRoaXMuZ2wuY2FudmFzLmhlaWdodCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLCB0aGlzLnJlbmRlclNjYWxlKTtcbiAgICAgIHRoaXMucmVzb2x1dGlvbkNoYW5nZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5nbC5kcmF3QXJyYXlzKHRoaXMuZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICBpZiAodGhpcy5zcGVlZCAhPT0gMCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgfTtcbiAgcmVxdWVzdFJlbmRlciA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgfVxuICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICB9O1xuICAvKiogQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBpbWFnZSBhbmQgc2V0cyBpdCBpbnRvIGEgdW5pZm9ybSB2YWx1ZSAqL1xuICBzZXRUZXh0dXJlVW5pZm9ybSA9ICh1bmlmb3JtTmFtZSwgaW1hZ2UpID0+IHtcbiAgICBpZiAoIWltYWdlLmNvbXBsZXRlIHx8IGltYWdlLm5hdHVyYWxXaWR0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXBlciBTaGFkZXJzOiBpbWFnZSBmb3IgdW5pZm9ybSAke3VuaWZvcm1OYW1lfSBtdXN0IGJlIGZ1bGx5IGxvYWRlZGApO1xuICAgIH1cbiAgICBjb25zdCBleGlzdGluZ1RleHR1cmUgPSB0aGlzLnRleHR1cmVzLmdldCh1bmlmb3JtTmFtZSk7XG4gICAgaWYgKGV4aXN0aW5nVGV4dHVyZSkge1xuICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKGV4aXN0aW5nVGV4dHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5SRVBFQVQpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuUkVQRUFUKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5MSU5FQVIpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLkxJTkVBUik7XG4gICAgdGhpcy5nbC50ZXhJbWFnZTJEKHRoaXMuZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlJHQkEsIHRoaXMuZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuICAgIGNvbnN0IGVycm9yID0gdGhpcy5nbC5nZXRFcnJvcigpO1xuICAgIGlmIChlcnJvciAhPT0gdGhpcy5nbC5OT19FUlJPUiB8fCB0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiUGFwZXIgU2hhZGVyczogV2ViR0wgZXJyb3Igd2hlbiB1cGxvYWRpbmcgdGV4dHVyZTpcIiwgZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRleHR1cmVzLnNldCh1bmlmb3JtTmFtZSwgdGV4dHVyZSk7XG4gICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdO1xuICAgIGlmIChsb2NhdGlvbikge1xuICAgICAgY29uc3QgdGV4dHVyZVVuaXQgPSB0aGlzLnRleHR1cmVzLnNpemUgLSAxO1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG4gICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb1VuaWZvcm1OYW1lID0gYCR7dW5pZm9ybU5hbWV9X2FzcGVjdF9yYXRpb2A7XG4gICAgICBjb25zdCBhc3BlY3RSYXRpb0xvY2F0aW9uID0gdGhpcy51bmlmb3JtTG9jYXRpb25zW2FzcGVjdFJhdGlvVW5pZm9ybU5hbWVdO1xuICAgICAgaWYgKGFzcGVjdFJhdGlvTG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgYXNwZWN0UmF0aW8gPSBpbWFnZS5uYXR1cmFsV2lkdGggLyBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZihhc3BlY3RSYXRpb0xvY2F0aW9uLCBhc3BlY3RSYXRpbyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKiogVXRpbGl0eTogcmVjdXJzaXZlIGVxdWFsaXR5IHRlc3QgZm9yIGFsbCB0aGUgdW5pZm9ybXMgKi9cbiAgYXJlVW5pZm9ybVZhbHVlc0VxdWFsID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBhLmV2ZXJ5KCh2YWwsIGkpID0+IHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHZhbCwgYltpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIC8qKiBTZXRzIHRoZSBwcm92aWRlZCB1bmlmb3JtIHZhbHVlcyBpbnRvIHRoZSBXZWJHTCBwcm9ncmFtLCBjYW4gYmUgYSBwYXJ0aWFsIGxpc3Qgb2YgdW5pZm9ybXMgdGhhdCBoYXZlIGNoYW5nZWQgKi9cbiAgc2V0VW5pZm9ybVZhbHVlcyA9ICh1cGRhdGVkVW5pZm9ybXMpID0+IHtcbiAgICB0aGlzLmdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtKTtcbiAgICBPYmplY3QuZW50cmllcyh1cGRhdGVkVW5pZm9ybXMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuYXJlVW5pZm9ybVZhbHVlc0VxdWFsKHRoaXMudW5pZm9ybUNhY2hlW2tleV0sIHZhbHVlKSkgcmV0dXJuO1xuICAgICAgY29uc3QgbG9jYXRpb24gPSB0aGlzLnVuaWZvcm1Mb2NhdGlvbnNba2V5XTtcbiAgICAgIGlmICghbG9jYXRpb24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBVbmlmb3JtIGxvY2F0aW9uIGZvciAke2tleX0gbm90IGZvdW5kYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlVW5pZm9ybShrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYXRBcnJheSA9IG51bGw7XG4gICAgICAgIGxldCB2YWx1ZUxlbmd0aCA9IG51bGw7XG4gICAgICAgIGlmICh2YWx1ZVswXSAhPT0gdm9pZCAwICYmIEFycmF5LmlzQXJyYXkodmFsdWVbMF0pKSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZExlbmd0aCA9IHZhbHVlWzBdLmxlbmd0aDtcbiAgICAgICAgICBpZiAodmFsdWUuZXZlcnkoKGFycikgPT4gYXJyLmxlbmd0aCA9PT0gZmlyc3RDaGlsZExlbmd0aCkpIHtcbiAgICAgICAgICAgIGZsYXRBcnJheSA9IHZhbHVlLmZsYXQoKTtcbiAgICAgICAgICAgIHZhbHVlTGVuZ3RoID0gZmlyc3RDaGlsZExlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBBbGwgY2hpbGQgYXJyYXlzIG11c3QgYmUgdGhlIHNhbWUgbGVuZ3RoIGZvciAke2tleX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEFycmF5ID0gdmFsdWU7XG4gICAgICAgICAgdmFsdWVMZW5ndGggPSBmbGF0QXJyYXkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWVMZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0zZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm00ZnYobG9jYXRpb24sIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCBmbGF0QXJyYXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIGZsYXRBcnJheSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnN1cHBvcnRlZCB1bmlmb3JtIGFycmF5IGxlbmd0aDogJHt2YWx1ZUxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYobG9jYXRpb24sIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdmFsdWUgPyAxIDogMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZSBmb3IgJHtrZXl9OiAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5pZm9ybUNhY2hlW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcbiAgfTtcbiAgLyoqIEdldHMgdGhlIGN1cnJlbnQgdG90YWwgYW5pbWF0aW9uIHRpbWUgZnJvbSAwbXMgKi9cbiAgZ2V0Q3VycmVudEZyYW1lVGltZSA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy50b3RhbEZyYW1lVGltZTtcbiAgfTtcbiAgLyoqIFNldCBhIGZyYW1lIHRvIGdldCBhIGRldGVybWluaXN0aWMgcmVzdWx0LCBmcmFtZXMgYXJlIGxpdGVyYWxseSBqdXN0IG1pbGxpc2Vjb25kcyBmcm9tIHplcm8gc2luY2UgdGhlIGFuaW1hdGlvbiBzdGFydGVkICovXG4gIHNldEZyYW1lID0gKG5ld0ZyYW1lKSA9PiB7XG4gICAgdGhpcy50b3RhbEZyYW1lVGltZSA9IG5ld0ZyYW1lO1xuICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH07XG4gIC8qKiBTZXQgYW4gYW5pbWF0aW9uIHNwZWVkIChvciAwIHRvIHN0b3AgYW5pbWF0aW9uKSAqL1xuICBzZXRTcGVlZCA9IChuZXdTcGVlZCA9IDEpID0+IHtcbiAgICB0aGlzLnNwZWVkID0gbmV3U3BlZWQ7XG4gICAgaWYgKHRoaXMucmFmSWQgPT09IG51bGwgJiYgbmV3U3BlZWQgIT09IDApIHtcbiAgICAgIHRoaXMubGFzdFJlbmRlclRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMucmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yYWZJZCAhPT0gbnVsbCAmJiBuZXdTcGVlZCA9PT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZCk7XG4gICAgICB0aGlzLnJhZklkID0gbnVsbDtcbiAgICB9XG4gIH07XG4gIC8qKiBTZXQgdGhlIG1heGltdW0gcGl4ZWwgY291bnQgZm9yIHRoZSBzaGFkZXIsIHRoaXMgd2lsbCBsaW1pdCB0aGUgbnVtYmVyIG9mIHBpeGVscyB0aGF0IHdpbGwgYmUgcmVuZGVyZWQgKi9cbiAgc2V0TWF4UGl4ZWxDb3VudCA9IChuZXdNYXhQaXhlbENvdW50ID0gREVGQVVMVF9NQVhfUElYRUxfQ09VTlQpID0+IHtcbiAgICB0aGlzLm1heFBpeGVsQ291bnQgPSBuZXdNYXhQaXhlbENvdW50O1xuICAgIHRoaXMuaGFuZGxlUmVzaXplKCk7XG4gIH07XG4gIC8qKiBTZXQgdGhlIG1pbmltdW0gcGl4ZWwgcmF0aW8gZm9yIHRoZSBzaGFkZXIgKi9cbiAgc2V0TWluUGl4ZWxSYXRpbyA9IChuZXdNaW5QaXhlbFJhdGlvID0gMikgPT4ge1xuICAgIHRoaXMubWluUGl4ZWxSYXRpbyA9IG5ld01pblBpeGVsUmF0aW87XG4gICAgdGhpcy5oYW5kbGVSZXNpemUoKTtcbiAgfTtcbiAgLyoqIFVwZGF0ZSB0aGUgdW5pZm9ybXMgdGhhdCBhcmUgcHJvdmlkZWQgYnkgdGhlIG91dHNpZGUgc2hhZGVyLCBjYW4gYmUgYSBwYXJ0aWFsIHNldCB3aXRoIG9ubHkgdGhlIHVuaWZvcm1zIHRoYXQgaGF2ZSBjaGFuZ2VkICovXG4gIHNldFVuaWZvcm1zID0gKG5ld1VuaWZvcm1zKSA9PiB7XG4gICAgdGhpcy5zZXRVbmlmb3JtVmFsdWVzKG5ld1VuaWZvcm1zKTtcbiAgICB0aGlzLnByb3ZpZGVkVW5pZm9ybXMgPSB7IC4uLnRoaXMucHJvdmlkZWRVbmlmb3JtcywgLi4ubmV3VW5pZm9ybXMgfTtcbiAgICB0aGlzLnJlbmRlcihwZXJmb3JtYW5jZS5ub3coKSk7XG4gIH07XG4gIC8qKiBEaXNwb3NlIG9mIHRoZSBzaGFkZXIgbW91bnQsIGNsZWFuaW5nIHVwIGFsbCBvZiB0aGUgV2ViR0wgcmVzb3VyY2VzICovXG4gIGRpc3Bvc2UgPSAoKSA9PiB7XG4gICAgdGhpcy5oYXNCZWVuRGlzcG9zZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnJhZklkICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKTtcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5nbCAmJiB0aGlzLnByb2dyYW0pIHtcbiAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCgodGV4dHVyZSkgPT4ge1xuICAgICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMudGV4dHVyZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbiAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmJpbmRSZW5kZXJidWZmZXIodGhpcy5nbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLmdsLmdldEVycm9yKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgICB2aXN1YWxWaWV3cG9ydD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmhhbmRsZVZpc3VhbFZpZXdwb3J0Q2hhbmdlKTtcbiAgICB0aGlzLnVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICB0aGlzLnBhcmVudEVsZW1lbnQucGFwZXJTaGFkZXJNb3VudCA9IHZvaWQgMDtcbiAgfTtcbn1cbmNvbnN0IHZlcnRleFNoYWRlclNvdXJjZSA9IGAjdmVyc2lvbiAzMDAgZXNcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG5sYXlvdXQobG9jYXRpb24gPSAwKSBpbiB2ZWM0IGFfcG9zaXRpb247XG5cbnVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247XG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcblxudW5pZm9ybSBmbG9hdCB1X29yaWdpblg7XG51bmlmb3JtIGZsb2F0IHVfb3JpZ2luWTtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZFdpZHRoO1xudW5pZm9ybSBmbG9hdCB1X3dvcmxkSGVpZ2h0O1xudW5pZm9ybSBmbG9hdCB1X2ZpdDtcblxudW5pZm9ybSBmbG9hdCB1X3NjYWxlO1xudW5pZm9ybSBmbG9hdCB1X3JvdGF0aW9uO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFg7XG51bmlmb3JtIGZsb2F0IHVfb2Zmc2V0WTtcblxudW5pZm9ybSBmbG9hdCB1X3B4U2l6ZTtcblxub3V0IHZlYzIgdl9vYmplY3RVVjtcbm91dCB2ZWMyIHZfb2JqZWN0Qm94U2l6ZTtcbm91dCB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuXG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVVVjtcbm91dCB2ZWMyIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5vdXQgdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5cbm91dCB2ZWMyIHZfcGF0dGVyblVWO1xub3V0IHZlYzIgdl9wYXR0ZXJuQm94U2l6ZTtcbm91dCB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtcblxuLy8gI2RlZmluZSBBRERfSEVMUEVSU1xuXG52ZWMzIGdldEJveFNpemUoZmxvYXQgYm94UmF0aW8sIHZlYzIgZ2l2ZW5Cb3hTaXplLCB2ZWMyIG1heEJveFNpemUpIHtcbiAgdmVjMiBib3ggPSB2ZWMyKDAuKTtcbiAgLy8gZml0ID0gbm9uZVxuICBib3gueCA9IGJveFJhdGlvICogbWluKGdpdmVuQm94U2l6ZS54IC8gYm94UmF0aW8sIGdpdmVuQm94U2l6ZS55KTtcbiAgZmxvYXQgbm9GaXRCb3hXaWR0aCA9IGJveC54O1xuICBpZiAodV9maXQgPT0gMS4pIHsgLy8gZml0ID0gY29udGFpblxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtaW4obWF4Qm94U2l6ZVswXSAvIGJveFJhdGlvLCBtYXhCb3hTaXplWzFdKTtcbiAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAvLyBmaXQgPSBjb3ZlclxuICAgIGJveC54ID0gYm94UmF0aW8gKiBtYXgobWF4Qm94U2l6ZVswXSAvIGJveFJhdGlvLCBtYXhCb3hTaXplWzFdKTtcbiAgfVxuICBib3gueSA9IGJveC54IC8gYm94UmF0aW87XG4gIHJldHVybiB2ZWMzKGJveCwgbm9GaXRCb3hXaWR0aCk7XG59XG5cbnZvaWQgbWFpbigpIHtcbiAgZ2xfUG9zaXRpb24gPSBhX3Bvc2l0aW9uO1xuXG4gIHZlYzIgdXYgPSBnbF9Qb3NpdGlvbi54eSAqIC41O1xuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgdmVjMiBtYXhCb3hTaXplID0gdmVjMihtYXgodV9yZXNvbHV0aW9uLngsIGdpdmVuQm94U2l6ZS54KSwgbWF4KHVfcmVzb2x1dGlvbi55LCBnaXZlbkJveFNpemUueSkpO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBncmFwaGljIG9iamVjdHMgd2l0aCBmaXhlZCByYXRpb1xuICAvLyAoY3VycmVudGx5IHN1cHBvcnRzIG9ubHkgcmF0aW8gPSAxKVxuXG4gIGZsb2F0IGZpeGVkUmF0aW8gPSAxLjtcbiAgdmVjMiBmaXhlZFJhdGlvQm94R2l2ZW5TaXplID0gdmVjMihcbiAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICApO1xuXG4gIHZfb2JqZWN0Qm94U2l6ZSA9IGdldEJveFNpemUoZml4ZWRSYXRpbywgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSwgbWF4Qm94U2l6ZSkueHk7XG4gIHZlYzIgb2JqZWN0V29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfb2JqZWN0Qm94U2l6ZTtcblxuICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICB2X29iamVjdEhlbHBlckJveCA9IHV2O1xuICAgIHZfb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgdl9vYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICNlbmRpZlxuXG4gIHZfb2JqZWN0VVYgPSB1djtcbiAgdl9vYmplY3RVViAqPSBvYmplY3RXb3JsZFNjYWxlO1xuICB2X29iamVjdFVWICs9IGJveE9yaWdpbiAqIChvYmplY3RXb3JsZFNjYWxlIC0gMS4pO1xuICB2X29iamVjdFVWICs9IGdyYXBoaWNPZmZzZXQ7XG4gIHZfb2JqZWN0VVYgLz0gdV9zY2FsZTtcbiAgdl9vYmplY3RVViA9IGdyYXBoaWNSb3RhdGlvbiAqIHZfb2JqZWN0VVY7XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTaXppbmcgYXBpIGZvciBncmFwaGljIG9iamVjdHMgd2l0aCBlaXRoZXIgZ2l2ZW5Cb3hTaXplIHJhdGlvIG9yIGNhbnZhcyByYXRpby5cbiAgLy8gRnVsbC1zY3JlZW4gbW9kZSBhdmFpbGFibGUgd2l0aCB1X3dvcmxkV2lkdGggPSB1X3dvcmxkSGVpZ2h0ID0gMFxuXG4gIHZfcmVzcG9uc2l2ZUJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgZmxvYXQgcmVzcG9uc2l2ZVJhdGlvID0gdl9yZXNwb25zaXZlQm94R2l2ZW5TaXplLnggLyB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUueTtcbiAgdl9yZXNwb25zaXZlQm94U2l6ZSA9IGdldEJveFNpemUocmVzcG9uc2l2ZVJhdGlvLCB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemUsIG1heEJveFNpemUpLnh5O1xuICB2ZWMyIHJlc3BvbnNpdmVCb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcmVzcG9uc2l2ZUJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gICAgdl9yZXNwb25zaXZlSGVscGVyQm94ID0gdXY7XG4gICAgdl9yZXNwb25zaXZlSGVscGVyQm94ICo9IHJlc3BvbnNpdmVCb3hTY2FsZTtcbiAgICB2X3Jlc3BvbnNpdmVIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHJlc3BvbnNpdmVCb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9yZXNwb25zaXZlVVYgPSB1djtcbiAgdl9yZXNwb25zaXZlVVYgKj0gcmVzcG9uc2l2ZUJveFNjYWxlO1xuICB2X3Jlc3BvbnNpdmVVViArPSBib3hPcmlnaW4gKiAocmVzcG9uc2l2ZUJveFNjYWxlIC0gMS4pO1xuICB2X3Jlc3BvbnNpdmVVViArPSBncmFwaGljT2Zmc2V0O1xuICB2X3Jlc3BvbnNpdmVVViAvPSB1X3NjYWxlO1xuICB2X3Jlc3BvbnNpdmVVVi54ICo9IHJlc3BvbnNpdmVSYXRpbztcbiAgdl9yZXNwb25zaXZlVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3Jlc3BvbnNpdmVVVjtcbiAgdl9yZXNwb25zaXZlVVYueCAvPSByZXNwb25zaXZlUmF0aW87XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2l6aW5nIGFwaSBmb3IgcGF0dGVybnNcbiAgLy8gKHRyZWF0aW5nIGdyYXBoaWNzIGFzIGEgaW1hZ2UgdV93b3JsZFdpZHRoIHggdV93b3JsZEhlaWdodCBzaXplKVxuXG4gIGZsb2F0IHBhdHRlcm5Cb3hSYXRpbyA9IGdpdmVuQm94U2l6ZS54IC8gZ2l2ZW5Cb3hTaXplLnk7XG4gIHZlYzIgcGF0dGVybkJveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICh1X3dvcmxkSGVpZ2h0ID09IDAuKSA/IHVfcmVzb2x1dGlvbi55IDogZ2l2ZW5Cb3hTaXplLnlcbiAgKTtcbiAgcGF0dGVybkJveFJhdGlvID0gcGF0dGVybkJveEdpdmVuU2l6ZS54IC8gcGF0dGVybkJveEdpdmVuU2l6ZS55O1xuXG4gIHZlYzMgYm94U2l6ZURhdGEgPSBnZXRCb3hTaXplKHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZSwgbWF4Qm94U2l6ZSk7XG4gIHZfcGF0dGVybkJveFNpemUgPSBib3hTaXplRGF0YS54eTtcbiAgZmxvYXQgcGF0dGVybkJveE5vRml0Qm94V2lkdGggPSBib3hTaXplRGF0YS56O1xuICB2ZWMyIHBhdHRlcm5Cb3hTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHZfcGF0dGVybkJveFNpemU7XG5cbiAgI2lmZGVmIEFERF9IRUxQRVJTXG4gICAgdl9wYXR0ZXJuSGVscGVyQm94ID0gdXY7XG4gICAgdl9wYXR0ZXJuSGVscGVyQm94ICo9IHBhdHRlcm5Cb3hTY2FsZTtcbiAgICB2X3BhdHRlcm5IZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKHBhdHRlcm5Cb3hTY2FsZSAtIDEuKTtcbiAgI2VuZGlmXG5cbiAgdl9wYXR0ZXJuVVYgPSB1djtcbiAgdl9wYXR0ZXJuVVYgKz0gZ3JhcGhpY09mZnNldCAvIHBhdHRlcm5Cb3hTY2FsZTtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuQm94U2NhbGU7XG4gIHZfcGF0dGVyblVWICo9IHVfcmVzb2x1dGlvbi54eTtcbiAgdl9wYXR0ZXJuVVYgLz0gdV9waXhlbFJhdGlvO1xuICBpZiAodV9maXQgPiAwLikge1xuICAgIHZfcGF0dGVyblVWICo9IChwYXR0ZXJuQm94Tm9GaXRCb3hXaWR0aCAvIHZfcGF0dGVybkJveFNpemUueCk7XG4gIH1cbiAgdl9wYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgdl9wYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiB2X3BhdHRlcm5VVjtcbiAgdl9wYXR0ZXJuVVYgKz0gYm94T3JpZ2luIC8gcGF0dGVybkJveFNjYWxlO1xuICB2X3BhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gIHZfcGF0dGVyblVWICs9IC41O1xuXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG59YDtcbmZ1bmN0aW9uIGNyZWF0ZVNoYWRlcihnbCwgdHlwZSwgc291cmNlKSB7XG4gIGNvbnN0IHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcbiAgaWYgKCFzaGFkZXIpIHJldHVybiBudWxsO1xuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkFuIGVycm9yIG9jY3VycmVkIGNvbXBpbGluZyB0aGUgc2hhZGVyczogXCIgKyBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UyLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSBjcmVhdGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNoYWRlclNvdXJjZTIpO1xuICBjb25zdCBmcmFnbWVudFNoYWRlciA9IGNyZWF0ZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gIGlmICghdmVydGV4U2hhZGVyIHx8ICFmcmFnbWVudFNoYWRlcikgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmICghcHJvZ3JhbSkgcmV0dXJuIG51bGw7XG4gIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgc2hhZGVyIHByb2dyYW06IFwiICsgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnbC5kZXRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcbiAgZ2wuZGV0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIHJldHVybiBwcm9ncmFtO1xufVxuY29uc3QgZGVmYXVsdFN0eWxlID0gYEBsYXllciBwYXBlci1zaGFkZXJzIHtcbiAgOndoZXJlKFtkYXRhLXBhcGVyLXNoYWRlcl0pIHtcbiAgICBpc29sYXRpb246IGlzb2xhdGU7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgJiBjYW52YXMge1xuICAgICAgY29udGFpbjogc3RyaWN0O1xuICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICBpbnNldDogMDtcbiAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgIH1cbiAgfVxufWA7XG5mdW5jdGlvbiBpc1BhcGVyU2hhZGVyRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBcInBhcGVyU2hhZGVyTW91bnRcIiBpbiBlbGVtZW50O1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gdWEuaW5jbHVkZXMoXCJzYWZhcmlcIikgJiYgIXVhLmluY2x1ZGVzKFwiY2hyb21lXCIpICYmICF1YS5pbmNsdWRlcyhcImFuZHJvaWRcIik7XG59XG5leHBvcnQge1xuICBTaGFkZXJNb3VudCxcbiAgaXNQYXBlclNoYWRlckVsZW1lbnRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItbW91bnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-mount.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-sizing.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-sizing.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShaderFitOptions: () => (/* binding */ ShaderFitOptions),\n/* harmony export */   defaultObjectSizing: () => (/* binding */ defaultObjectSizing),\n/* harmony export */   defaultPatternSizing: () => (/* binding */ defaultPatternSizing),\n/* harmony export */   drawSizingHelpers: () => (/* binding */ drawSizingHelpers),\n/* harmony export */   sizingDebugVariablesDeclaration: () => (/* binding */ sizingDebugVariablesDeclaration),\n/* harmony export */   sizingUV: () => (/* binding */ sizingUV),\n/* harmony export */   sizingUniformsDeclaration: () => (/* binding */ sizingUniformsDeclaration),\n/* harmony export */   sizingVariablesDeclaration: () => (/* binding */ sizingVariablesDeclaration)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst sizingVariablesDeclaration = `\nin vec2 v_objectUV;\nin vec2 v_responsiveUV;\nin vec2 v_responsiveBoxGivenSize;\nin vec2 v_patternUV;`;\nconst sizingDebugVariablesDeclaration = `\nin vec2 v_objectBoxSize;\nin vec2 v_objectHelperBox;\nin vec2 v_responsiveBoxSize;\nin vec2 v_responsiveHelperBox;\nin vec2 v_patternBoxSize;\nin vec2 v_patternHelperBox;`;\nconst sizingUniformsDeclaration = `\nuniform float u_originX;\nuniform float u_originY;\nuniform float u_worldWidth;\nuniform float u_worldHeight;\nuniform float u_fit;\n\nuniform float u_scale;\nuniform float u_rotation;\nuniform float u_offsetX;\nuniform float u_offsetY;`;\nconst sizingUV = `\n\n  vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n  #ifdef USE_PIXELIZATION\n    float pxSize = u_pxSize * u_pixelRatio;\n    vec2 pxSizeUv = gl_FragCoord.xy;\n    pxSizeUv -= .5 * u_resolution;\n    pxSizeUv /= pxSize;\n    uv = floor(pxSizeUv) * pxSize / u_resolution.xy;    \n    uv += .5;\n  #endif\n  uv -= .5;\n\n  \n  // ===================================================\n  // sizing params shared between objects and patterns\n  \n  vec2 boxOrigin = vec2(.5 - u_originX, u_originY - .5);\n  vec2 givenBoxSize = vec2(u_worldWidth, u_worldHeight);\n  givenBoxSize = max(givenBoxSize, vec2(1.)) * u_pixelRatio;\n  vec2 maxBoxSize = vec2(max(u_resolution.x, givenBoxSize.x), max(u_resolution.y, givenBoxSize.y));\n  float r = u_rotation * 3.14159265358979323846 / 180.;\n  mat2 graphicRotation = mat2(cos(r), sin(r), -sin(r), cos(r));\n  vec2 graphicOffset = vec2(-u_offsetX, u_offsetY);\n\n  \n  // ===================================================\n  // Sizing api for objects (graphics with fixed ratio)\n\n  #ifdef USE_OBJECT_SIZING\n    float fixedRatio = 1.;\n    vec2 fixedRatioBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 objectBoxSize = vec2(0.);\n    // fit = none\n    objectBoxSize.x = fixedRatio * min(fixedRatioBoxGivenSize.x / fixedRatio, fixedRatioBoxGivenSize.y);\n    if (u_fit == 1.) { // fit = contain\n      objectBoxSize.x = fixedRatio * min(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      objectBoxSize.x = fixedRatio * max(maxBoxSize.x / fixedRatio, maxBoxSize.y);\n    }\n    objectBoxSize.y = objectBoxSize.x / fixedRatio;\n    vec2 objectWorldScale = u_resolution.xy / objectBoxSize;\n  \n    #ifdef ADD_HELPERS\n      vec2 objectHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      objectHelperBox -= .5;\n      objectHelperBox *= objectWorldScale;\n      objectHelperBox += boxOrigin * (objectWorldScale - 1.);  \n    #endif\n  \n    vec2 objectUV = uv;\n    objectUV *= objectWorldScale;\n    objectUV += boxOrigin * (objectWorldScale - 1.);\n    objectUV += vec2(-u_offsetX, u_offsetY);\n    objectUV /= u_scale;\n    objectUV = graphicRotation * objectUV;\n  #endif\n  \n  // ===================================================\n \n  // ===================================================\n  // Sizing api for patterns (graphics respecting u_worldWidth / u_worldHeight ratio)\n  \n  #ifdef USE_PATTERN_SIZING\n    float patternBoxRatio = givenBoxSize.x / givenBoxSize.y;\n    vec2 patternBoxGivenSize = vec2(\n      (u_worldWidth == 0.) ? u_resolution.x : givenBoxSize.x,\n      (u_worldHeight == 0.) ? u_resolution.y : givenBoxSize.y\n    );\n    vec2 patternBoxSize = vec2(0.);\n    // fit = none\n    patternBoxSize.x = patternBoxRatio * min(patternBoxGivenSize.x / patternBoxRatio, patternBoxGivenSize.y);\n    float patternWorldNoFitBoxWidth = patternBoxSize.x;\n    if (u_fit == 1.) {  // fit = contain\n      patternBoxSize.x = patternBoxRatio * min(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    } else if (u_fit == 2.) {  // fit = cover\n      patternBoxSize.x = patternBoxRatio * max(maxBoxSize.x / patternBoxRatio, maxBoxSize.y);\n    }\n    patternBoxSize.y = patternBoxSize.x / patternBoxRatio;\n    vec2 patternWorldScale = u_resolution.xy / patternBoxSize;\n  \n    #ifdef ADD_HELPERS  \n      vec2 patternHelperBox = gl_FragCoord.xy / u_resolution.xy;\n      patternHelperBox -= .5;\n      patternHelperBox *= patternWorldScale;\n      patternHelperBox += boxOrigin * (patternWorldScale - 1.);  \n    #endif\n  \n    vec2 patternUV = uv;\n    patternUV += vec2(-u_offsetX, u_offsetY) / patternWorldScale;\n    patternUV += boxOrigin;\n    patternUV -= boxOrigin / patternWorldScale;\n    patternUV *= u_resolution.xy;\n    patternUV /= u_pixelRatio;\n    if (u_fit > 0.) {\n      patternUV *= (patternWorldNoFitBoxWidth / patternBoxSize.x);\n    }\n    patternUV /= u_scale;\n    patternUV = graphicRotation * patternUV;\n    patternUV += boxOrigin / patternWorldScale;\n    patternUV -= boxOrigin;\n    patternUV += .5;\n  #endif\n`;\nconst drawSizingHelpers = `\n  vec2 worldBoxDist = abs(helperBox);\n  float boxStroke = (step(max(worldBoxDist.x, worldBoxDist.y), .5) - step(max(worldBoxDist.x, worldBoxDist.y), .495));\n  color.rgb = mix(color.rgb, vec3(1., 0., 0.), boxStroke);\n  opacity += boxStroke;\n\n  vec2 boxOriginCopy = vec2(.5 - u_originX, u_originY - .5);\n  vec2 boxOriginDist = helperBox + boxOriginCopy;\n  boxOriginDist.x *= (boxSize.x / boxSize.y);\n  float boxOriginPoint = 1. - smoothstep(0., .05, length(boxOriginDist));\n  \n  vec2 graphicOriginPointDist = helperBox + vec2(-u_offsetX, u_offsetY);\n  graphicOriginPointDist.x *= (boxSize.x / boxSize.y);\n  float graphicOriginPoint = 1. - smoothstep(0., .05, length(graphicOriginPointDist));\n  \n  color.rgb = mix(color.rgb, vec3(0., 1., 0.), boxOriginPoint);\n  opacity += boxOriginPoint;\n  color.rgb = mix(color.rgb, vec3(0., 0., 1.), graphicOriginPoint);\n  opacity += graphicOriginPoint;\n`;\nconst defaultObjectSizing = {\n  fit: \"contain\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst defaultPatternSizing = {\n  fit: \"none\",\n  scale: 1,\n  rotation: 0,\n  offsetX: 0,\n  offsetY: 0,\n  originX: 0.5,\n  originY: 0.5,\n  worldWidth: 0,\n  worldHeight: 0\n};\nconst ShaderFitOptions = {\n  none: 0,\n  contain: 1,\n  cover: 2\n};\n\n//# sourceMappingURL=shader-sizing.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOS9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXNpemluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLE1BQU0seUJBQXlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxNQUFNLHlCQUF5QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGFubWlcXFVuaXZlcnNpdHkgU3R1ZmZcXENvZGluZyBQcm9qZWN0c1xcdHVyYm9yZWFkXFxhcHBzXFx3ZWJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBwYXBlci1kZXNpZ24rc2hhZGVyc0AwLjAuMzlcXG5vZGVfbW9kdWxlc1xcQHBhcGVyLWRlc2lnblxcc2hhZGVyc1xcZGlzdFxcc2hhZGVyLXNpemluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuY29uc3Qgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb24gPSBgXG5pbiB2ZWMyIHZfb2JqZWN0VVY7XG5pbiB2ZWMyIHZfcmVzcG9uc2l2ZVVWO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hHaXZlblNpemU7XG5pbiB2ZWMyIHZfcGF0dGVyblVWO2A7XG5jb25zdCBzaXppbmdEZWJ1Z1ZhcmlhYmxlc0RlY2xhcmF0aW9uID0gYFxuaW4gdmVjMiB2X29iamVjdEJveFNpemU7XG5pbiB2ZWMyIHZfb2JqZWN0SGVscGVyQm94O1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVCb3hTaXplO1xuaW4gdmVjMiB2X3Jlc3BvbnNpdmVIZWxwZXJCb3g7XG5pbiB2ZWMyIHZfcGF0dGVybkJveFNpemU7XG5pbiB2ZWMyIHZfcGF0dGVybkhlbHBlckJveDtgO1xuY29uc3Qgc2l6aW5nVW5pZm9ybXNEZWNsYXJhdGlvbiA9IGBcbnVuaWZvcm0gZmxvYXQgdV9vcmlnaW5YO1xudW5pZm9ybSBmbG9hdCB1X29yaWdpblk7XG51bmlmb3JtIGZsb2F0IHVfd29ybGRXaWR0aDtcbnVuaWZvcm0gZmxvYXQgdV93b3JsZEhlaWdodDtcbnVuaWZvcm0gZmxvYXQgdV9maXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV9zY2FsZTtcbnVuaWZvcm0gZmxvYXQgdV9yb3RhdGlvbjtcbnVuaWZvcm0gZmxvYXQgdV9vZmZzZXRYO1xudW5pZm9ybSBmbG9hdCB1X29mZnNldFk7YDtcbmNvbnN0IHNpemluZ1VWID0gYFxuXG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1X3Jlc29sdXRpb24ueHk7XG4gICNpZmRlZiBVU0VfUElYRUxJWkFUSU9OXG4gICAgZmxvYXQgcHhTaXplID0gdV9weFNpemUgKiB1X3BpeGVsUmF0aW87XG4gICAgdmVjMiBweFNpemVVdiA9IGdsX0ZyYWdDb29yZC54eTtcbiAgICBweFNpemVVdiAtPSAuNSAqIHVfcmVzb2x1dGlvbjtcbiAgICBweFNpemVVdiAvPSBweFNpemU7XG4gICAgdXYgPSBmbG9vcihweFNpemVVdikgKiBweFNpemUgLyB1X3Jlc29sdXRpb24ueHk7ICAgIFxuICAgIHV2ICs9IC41O1xuICAjZW5kaWZcbiAgdXYgLT0gLjU7XG5cbiAgXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBzaXppbmcgcGFyYW1zIHNoYXJlZCBiZXR3ZWVuIG9iamVjdHMgYW5kIHBhdHRlcm5zXG4gIFxuICB2ZWMyIGJveE9yaWdpbiA9IHZlYzIoLjUgLSB1X29yaWdpblgsIHVfb3JpZ2luWSAtIC41KTtcbiAgdmVjMiBnaXZlbkJveFNpemUgPSB2ZWMyKHVfd29ybGRXaWR0aCwgdV93b3JsZEhlaWdodCk7XG4gIGdpdmVuQm94U2l6ZSA9IG1heChnaXZlbkJveFNpemUsIHZlYzIoMS4pKSAqIHVfcGl4ZWxSYXRpbztcbiAgdmVjMiBtYXhCb3hTaXplID0gdmVjMihtYXgodV9yZXNvbHV0aW9uLngsIGdpdmVuQm94U2l6ZS54KSwgbWF4KHVfcmVzb2x1dGlvbi55LCBnaXZlbkJveFNpemUueSkpO1xuICBmbG9hdCByID0gdV9yb3RhdGlvbiAqIDMuMTQxNTkyNjUzNTg5NzkzMjM4NDYgLyAxODAuO1xuICBtYXQyIGdyYXBoaWNSb3RhdGlvbiA9IG1hdDIoY29zKHIpLCBzaW4ociksIC1zaW4ociksIGNvcyhyKSk7XG4gIHZlYzIgZ3JhcGhpY09mZnNldCA9IHZlYzIoLXVfb2Zmc2V0WCwgdV9vZmZzZXRZKTtcblxuICBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIG9iamVjdHMgKGdyYXBoaWNzIHdpdGggZml4ZWQgcmF0aW8pXG5cbiAgI2lmZGVmIFVTRV9PQkpFQ1RfU0laSU5HXG4gICAgZmxvYXQgZml4ZWRSYXRpbyA9IDEuO1xuICAgIHZlYzIgZml4ZWRSYXRpb0JveEdpdmVuU2l6ZSA9IHZlYzIoXG4gICAgICAodV93b3JsZFdpZHRoID09IDAuKSA/IHVfcmVzb2x1dGlvbi54IDogZ2l2ZW5Cb3hTaXplLngsXG4gICAgICAodV93b3JsZEhlaWdodCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueSA6IGdpdmVuQm94U2l6ZS55XG4gICAgKTtcbiAgICB2ZWMyIG9iamVjdEJveFNpemUgPSB2ZWMyKDAuKTtcbiAgICAvLyBmaXQgPSBub25lXG4gICAgb2JqZWN0Qm94U2l6ZS54ID0gZml4ZWRSYXRpbyAqIG1pbihmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnggLyBmaXhlZFJhdGlvLCBmaXhlZFJhdGlvQm94R2l2ZW5TaXplLnkpO1xuICAgIGlmICh1X2ZpdCA9PSAxLikgeyAvLyBmaXQgPSBjb250YWluXG4gICAgICBvYmplY3RCb3hTaXplLnggPSBmaXhlZFJhdGlvICogbWluKG1heEJveFNpemUueCAvIGZpeGVkUmF0aW8sIG1heEJveFNpemUueSk7XG4gICAgfSBlbHNlIGlmICh1X2ZpdCA9PSAyLikgeyAgLy8gZml0ID0gY292ZXJcbiAgICAgIG9iamVjdEJveFNpemUueCA9IGZpeGVkUmF0aW8gKiBtYXgobWF4Qm94U2l6ZS54IC8gZml4ZWRSYXRpbywgbWF4Qm94U2l6ZS55KTtcbiAgICB9XG4gICAgb2JqZWN0Qm94U2l6ZS55ID0gb2JqZWN0Qm94U2l6ZS54IC8gZml4ZWRSYXRpbztcbiAgICB2ZWMyIG9iamVjdFdvcmxkU2NhbGUgPSB1X3Jlc29sdXRpb24ueHkgLyBvYmplY3RCb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlNcbiAgICAgIHZlYzIgb2JqZWN0SGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgb2JqZWN0SGVscGVyQm94IC09IC41O1xuICAgICAgb2JqZWN0SGVscGVyQm94ICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgICBvYmplY3RIZWxwZXJCb3ggKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7ICBcbiAgICAjZW5kaWZcbiAgXG4gICAgdmVjMiBvYmplY3RVViA9IHV2O1xuICAgIG9iamVjdFVWICo9IG9iamVjdFdvcmxkU2NhbGU7XG4gICAgb2JqZWN0VVYgKz0gYm94T3JpZ2luICogKG9iamVjdFdvcmxkU2NhbGUgLSAxLik7XG4gICAgb2JqZWN0VVYgKz0gdmVjMigtdV9vZmZzZXRYLCB1X29mZnNldFkpO1xuICAgIG9iamVjdFVWIC89IHVfc2NhbGU7XG4gICAgb2JqZWN0VVYgPSBncmFwaGljUm90YXRpb24gKiBvYmplY3RVVjtcbiAgI2VuZGlmXG4gIFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiBcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFNpemluZyBhcGkgZm9yIHBhdHRlcm5zIChncmFwaGljcyByZXNwZWN0aW5nIHVfd29ybGRXaWR0aCAvIHVfd29ybGRIZWlnaHQgcmF0aW8pXG4gIFxuICAjaWZkZWYgVVNFX1BBVFRFUk5fU0laSU5HXG4gICAgZmxvYXQgcGF0dGVybkJveFJhdGlvID0gZ2l2ZW5Cb3hTaXplLnggLyBnaXZlbkJveFNpemUueTtcbiAgICB2ZWMyIHBhdHRlcm5Cb3hHaXZlblNpemUgPSB2ZWMyKFxuICAgICAgKHVfd29ybGRXaWR0aCA9PSAwLikgPyB1X3Jlc29sdXRpb24ueCA6IGdpdmVuQm94U2l6ZS54LFxuICAgICAgKHVfd29ybGRIZWlnaHQgPT0gMC4pID8gdV9yZXNvbHV0aW9uLnkgOiBnaXZlbkJveFNpemUueVxuICAgICk7XG4gICAgdmVjMiBwYXR0ZXJuQm94U2l6ZSA9IHZlYzIoMC4pO1xuICAgIC8vIGZpdCA9IG5vbmVcbiAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWluKHBhdHRlcm5Cb3hHaXZlblNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgcGF0dGVybkJveEdpdmVuU2l6ZS55KTtcbiAgICBmbG9hdCBwYXR0ZXJuV29ybGROb0ZpdEJveFdpZHRoID0gcGF0dGVybkJveFNpemUueDtcbiAgICBpZiAodV9maXQgPT0gMS4pIHsgIC8vIGZpdCA9IGNvbnRhaW5cbiAgICAgIHBhdHRlcm5Cb3hTaXplLnggPSBwYXR0ZXJuQm94UmF0aW8gKiBtaW4obWF4Qm94U2l6ZS54IC8gcGF0dGVybkJveFJhdGlvLCBtYXhCb3hTaXplLnkpO1xuICAgIH0gZWxzZSBpZiAodV9maXQgPT0gMi4pIHsgIC8vIGZpdCA9IGNvdmVyXG4gICAgICBwYXR0ZXJuQm94U2l6ZS54ID0gcGF0dGVybkJveFJhdGlvICogbWF4KG1heEJveFNpemUueCAvIHBhdHRlcm5Cb3hSYXRpbywgbWF4Qm94U2l6ZS55KTtcbiAgICB9XG4gICAgcGF0dGVybkJveFNpemUueSA9IHBhdHRlcm5Cb3hTaXplLnggLyBwYXR0ZXJuQm94UmF0aW87XG4gICAgdmVjMiBwYXR0ZXJuV29ybGRTY2FsZSA9IHVfcmVzb2x1dGlvbi54eSAvIHBhdHRlcm5Cb3hTaXplO1xuICBcbiAgICAjaWZkZWYgQUREX0hFTFBFUlMgIFxuICAgICAgdmVjMiBwYXR0ZXJuSGVscGVyQm94ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdV9yZXNvbHV0aW9uLnh5O1xuICAgICAgcGF0dGVybkhlbHBlckJveCAtPSAuNTtcbiAgICAgIHBhdHRlcm5IZWxwZXJCb3ggKj0gcGF0dGVybldvcmxkU2NhbGU7XG4gICAgICBwYXR0ZXJuSGVscGVyQm94ICs9IGJveE9yaWdpbiAqIChwYXR0ZXJuV29ybGRTY2FsZSAtIDEuKTsgIFxuICAgICNlbmRpZlxuICBcbiAgICB2ZWMyIHBhdHRlcm5VViA9IHV2O1xuICAgIHBhdHRlcm5VViArPSB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSkgLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKz0gYm94T3JpZ2luO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW4gLyBwYXR0ZXJuV29ybGRTY2FsZTtcbiAgICBwYXR0ZXJuVVYgKj0gdV9yZXNvbHV0aW9uLnh5O1xuICAgIHBhdHRlcm5VViAvPSB1X3BpeGVsUmF0aW87XG4gICAgaWYgKHVfZml0ID4gMC4pIHtcbiAgICAgIHBhdHRlcm5VViAqPSAocGF0dGVybldvcmxkTm9GaXRCb3hXaWR0aCAvIHBhdHRlcm5Cb3hTaXplLngpO1xuICAgIH1cbiAgICBwYXR0ZXJuVVYgLz0gdV9zY2FsZTtcbiAgICBwYXR0ZXJuVVYgPSBncmFwaGljUm90YXRpb24gKiBwYXR0ZXJuVVY7XG4gICAgcGF0dGVyblVWICs9IGJveE9yaWdpbiAvIHBhdHRlcm5Xb3JsZFNjYWxlO1xuICAgIHBhdHRlcm5VViAtPSBib3hPcmlnaW47XG4gICAgcGF0dGVyblVWICs9IC41O1xuICAjZW5kaWZcbmA7XG5jb25zdCBkcmF3U2l6aW5nSGVscGVycyA9IGBcbiAgdmVjMiB3b3JsZEJveERpc3QgPSBhYnMoaGVscGVyQm94KTtcbiAgZmxvYXQgYm94U3Ryb2tlID0gKHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC41KSAtIHN0ZXAobWF4KHdvcmxkQm94RGlzdC54LCB3b3JsZEJveERpc3QueSksIC40OTUpKTtcbiAgY29sb3IucmdiID0gbWl4KGNvbG9yLnJnYiwgdmVjMygxLiwgMC4sIDAuKSwgYm94U3Ryb2tlKTtcbiAgb3BhY2l0eSArPSBib3hTdHJva2U7XG5cbiAgdmVjMiBib3hPcmlnaW5Db3B5ID0gdmVjMiguNSAtIHVfb3JpZ2luWCwgdV9vcmlnaW5ZIC0gLjUpO1xuICB2ZWMyIGJveE9yaWdpbkRpc3QgPSBoZWxwZXJCb3ggKyBib3hPcmlnaW5Db3B5O1xuICBib3hPcmlnaW5EaXN0LnggKj0gKGJveFNpemUueCAvIGJveFNpemUueSk7XG4gIGZsb2F0IGJveE9yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChib3hPcmlnaW5EaXN0KSk7XG4gIFxuICB2ZWMyIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QgPSBoZWxwZXJCb3ggKyB2ZWMyKC11X29mZnNldFgsIHVfb2Zmc2V0WSk7XG4gIGdyYXBoaWNPcmlnaW5Qb2ludERpc3QueCAqPSAoYm94U2l6ZS54IC8gYm94U2l6ZS55KTtcbiAgZmxvYXQgZ3JhcGhpY09yaWdpblBvaW50ID0gMS4gLSBzbW9vdGhzdGVwKDAuLCAuMDUsIGxlbmd0aChncmFwaGljT3JpZ2luUG9pbnREaXN0KSk7XG4gIFxuICBjb2xvci5yZ2IgPSBtaXgoY29sb3IucmdiLCB2ZWMzKDAuLCAxLiwgMC4pLCBib3hPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gYm94T3JpZ2luUG9pbnQ7XG4gIGNvbG9yLnJnYiA9IG1peChjb2xvci5yZ2IsIHZlYzMoMC4sIDAuLCAxLiksIGdyYXBoaWNPcmlnaW5Qb2ludCk7XG4gIG9wYWNpdHkgKz0gZ3JhcGhpY09yaWdpblBvaW50O1xuYDtcbmNvbnN0IGRlZmF1bHRPYmplY3RTaXppbmcgPSB7XG4gIGZpdDogXCJjb250YWluXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgZGVmYXVsdFBhdHRlcm5TaXppbmcgPSB7XG4gIGZpdDogXCJub25lXCIsXG4gIHNjYWxlOiAxLFxuICByb3RhdGlvbjogMCxcbiAgb2Zmc2V0WDogMCxcbiAgb2Zmc2V0WTogMCxcbiAgb3JpZ2luWDogMC41LFxuICBvcmlnaW5ZOiAwLjUsXG4gIHdvcmxkV2lkdGg6IDAsXG4gIHdvcmxkSGVpZ2h0OiAwXG59O1xuY29uc3QgU2hhZGVyRml0T3B0aW9ucyA9IHtcbiAgbm9uZTogMCxcbiAgY29udGFpbjogMSxcbiAgY292ZXI6IDJcbn07XG5leHBvcnQge1xuICBTaGFkZXJGaXRPcHRpb25zLFxuICBkZWZhdWx0T2JqZWN0U2l6aW5nLFxuICBkZWZhdWx0UGF0dGVyblNpemluZyxcbiAgZHJhd1NpemluZ0hlbHBlcnMsXG4gIHNpemluZ0RlYnVnVmFyaWFibGVzRGVjbGFyYXRpb24sXG4gIHNpemluZ1VWLFxuICBzaXppbmdVbmlmb3Jtc0RlY2xhcmF0aW9uLFxuICBzaXppbmdWYXJpYWJsZXNEZWNsYXJhdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYWRlci1zaXppbmcuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-sizing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-utils.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-utils.js ***!
  \*****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   colorBandingFix: () => (/* binding */ colorBandingFix),\n/* harmony export */   declarePI: () => (/* binding */ declarePI),\n/* harmony export */   declareRandom: () => (/* binding */ declareRandom),\n/* harmony export */   declareRotate: () => (/* binding */ declareRotate),\n/* harmony export */   declareSimplexNoise: () => (/* binding */ declareSimplexNoise),\n/* harmony export */   declareValueNoise: () => (/* binding */ declareValueNoise)\n/* harmony export */ });\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\nconst declarePI = `\n#define TWO_PI 6.28318530718\n#define PI 3.14159265358979323846\n`;\nconst declareRotate = `\nvec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n`;\nconst declareRandom = `\nfloat random(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n`;\nconst declareValueNoise = `\nfloat valueNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n  float a = random(i);\n  float b = random(i + vec2(1.0, 0.0));\n  float c = random(i + vec2(0.0, 1.0));\n  float d = random(i + vec2(1.0, 1.0));\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  float x1 = mix(a, b, u.x);\n  float x2 = mix(c, d, u.x);\n  return mix(x1, x2, u.y);\n}\n`;\nconst colorBandingFix = `\n  color += 1. / 256. * (fract(sin(dot(.014 * gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453123) - .5);\n`;\nconst declareSimplexNoise = `\nvec3 permute(vec3 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nfloat snoise(vec2 v) {\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, 0.024390243902439);\n  vec2 i = floor(v + dot(v, C.yy));\n  vec2 x0 = v - i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n  vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n      dot(x12.zw, x12.zw)), 0.0);\n  m = m * m;\n  m = m * m;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n  vec3 g;\n  g.x = a0.x * x0.x + h.x * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n`;\n\n//# sourceMappingURL=shader-utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOS9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVyLXV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoYW5taVxcVW5pdmVyc2l0eSBTdHVmZlxcQ29kaW5nIFByb2plY3RzXFx0dXJib3JlYWRcXGFwcHNcXHdlYlxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOVxcbm9kZV9tb2R1bGVzXFxAcGFwZXItZGVzaWduXFxzaGFkZXJzXFxkaXN0XFxzaGFkZXItdXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqICAgICAgICAgICAgICAgICAgICBQYXBlciBTaGFkZXJzICAgICAgICAgICAgICAgICAgICAqXG4gKiAgICAgICBodHRwczovL2dpdGh1Yi5jb20vcGFwZXItZGVzaWduL3NoYWRlcnMgICAgICAgKlxuICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICovXG5cbmNvbnN0IGRlY2xhcmVQSSA9IGBcbiNkZWZpbmUgVFdPX1BJIDYuMjgzMTg1MzA3MThcbiNkZWZpbmUgUEkgMy4xNDE1OTI2NTM1ODk3OTMyMzg0NlxuYDtcbmNvbnN0IGRlY2xhcmVSb3RhdGUgPSBgXG52ZWMyIHJvdGF0ZSh2ZWMyIHV2LCBmbG9hdCB0aCkge1xuICByZXR1cm4gbWF0Mihjb3ModGgpLCBzaW4odGgpLCAtc2luKHRoKSwgY29zKHRoKSkgKiB1djtcbn1cbmA7XG5jb25zdCBkZWNsYXJlUmFuZG9tID0gYFxuZmxvYXQgcmFuZG9tKHZlYzIgc3QpIHtcbiAgcmV0dXJuIGZyYWN0KHNpbihkb3Qoc3QueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1MzEyMyk7XG59XG5gO1xuY29uc3QgZGVjbGFyZVZhbHVlTm9pc2UgPSBgXG5mbG9hdCB2YWx1ZU5vaXNlKHZlYzIgc3QpIHtcbiAgdmVjMiBpID0gZmxvb3Ioc3QpO1xuICB2ZWMyIGYgPSBmcmFjdChzdCk7XG4gIGZsb2F0IGEgPSByYW5kb20oaSk7XG4gIGZsb2F0IGIgPSByYW5kb20oaSArIHZlYzIoMS4wLCAwLjApKTtcbiAgZmxvYXQgYyA9IHJhbmRvbShpICsgdmVjMigwLjAsIDEuMCkpO1xuICBmbG9hdCBkID0gcmFuZG9tKGkgKyB2ZWMyKDEuMCwgMS4wKSk7XG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuICBmbG9hdCB4MSA9IG1peChhLCBiLCB1LngpO1xuICBmbG9hdCB4MiA9IG1peChjLCBkLCB1LngpO1xuICByZXR1cm4gbWl4KHgxLCB4MiwgdS55KTtcbn1cbmA7XG5jb25zdCBjb2xvckJhbmRpbmdGaXggPSBgXG4gIGNvbG9yICs9IDEuIC8gMjU2LiAqIChmcmFjdChzaW4oZG90KC4wMTQgKiBnbF9GcmFnQ29vcmQueHksIHZlYzIoMTIuOTg5OCwgNzguMjMzKSkpICogNDM3NTguNTQ1MzEyMykgLSAuNSk7XG5gO1xuY29uc3QgZGVjbGFyZVNpbXBsZXhOb2lzZSA9IGBcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZCgoKHggKiAzNC4wKSArIDEuMCkgKiB4LCAyODkuMCk7IH1cbmZsb2F0IHNub2lzZSh2ZWMyIHYpIHtcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NywgMC4zNjYwMjU0MDM3ODQ0MzksXG4gICAgLTAuNTc3MzUwMjY5MTg5NjI2LCAwLjAyNDM5MDI0MzkwMjQzOSk7XG4gIHZlYzIgaSA9IGZsb29yKHYgKyBkb3QodiwgQy55eSkpO1xuICB2ZWMyIHgwID0gdiAtIGkgKyBkb3QoaSwgQy54eCk7XG4gIHZlYzIgaTE7XG4gIGkxID0gKHgwLnggPiB4MC55KSA/IHZlYzIoMS4wLCAwLjApIDogdmVjMigwLjAsIDEuMCk7XG4gIHZlYzQgeDEyID0geDAueHl4eSArIEMueHh6ejtcbiAgeDEyLnh5IC09IGkxO1xuICBpID0gbW9kKGksIDI4OS4wKTtcbiAgdmVjMyBwID0gcGVybXV0ZShwZXJtdXRlKGkueSArIHZlYzMoMC4wLCBpMS55LCAxLjApKVxuICAgICsgaS54ICsgdmVjMygwLjAsIGkxLngsIDEuMCkpO1xuICB2ZWMzIG0gPSBtYXgoMC41IC0gdmVjMyhkb3QoeDAsIHgwKSwgZG90KHgxMi54eSwgeDEyLnh5KSxcbiAgICAgIGRvdCh4MTIuencsIHgxMi56dykpLCAwLjApO1xuICBtID0gbSAqIG07XG4gIG0gPSBtICogbTtcbiAgdmVjMyB4ID0gMi4wICogZnJhY3QocCAqIEMud3d3KSAtIDEuMDtcbiAgdmVjMyBoID0gYWJzKHgpIC0gMC41O1xuICB2ZWMzIG94ID0gZmxvb3IoeCArIDAuNSk7XG4gIHZlYzMgYTAgPSB4IC0gb3g7XG4gIG0gKj0gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiAoYTAgKiBhMCArIGggKiBoKTtcbiAgdmVjMyBnO1xuICBnLnggPSBhMC54ICogeDAueCArIGgueCAqIHgwLnk7XG4gIGcueXogPSBhMC55eiAqIHgxMi54eiArIGgueXogKiB4MTIueXc7XG4gIHJldHVybiAxMzAuMCAqIGRvdChtLCBnKTtcbn1cbmA7XG5leHBvcnQge1xuICBjb2xvckJhbmRpbmdGaXgsXG4gIGRlY2xhcmVQSSxcbiAgZGVjbGFyZVJhbmRvbSxcbiAgZGVjbGFyZVJvdGF0ZSxcbiAgZGVjbGFyZVNpbXBsZXhOb2lzZSxcbiAgZGVjbGFyZVZhbHVlTm9pc2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkZXItdXRpbHMuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js":
/*!**************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   meshGradientFragmentShader: () => (/* binding */ meshGradientFragmentShader),\n/* harmony export */   meshGradientMeta: () => (/* binding */ meshGradientMeta)\n/* harmony export */ });\n/* harmony import */ var _shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shader-sizing.js */ \"(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-sizing.js\");\n/* harmony import */ var _shader_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../shader-utils.js */ \"(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shader-utils.js\");\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * *\n *                    Paper Shaders                    *\n *       https://github.com/paper-design/shaders       *\n * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n\n\nconst meshGradientMeta = {\n  maxColorCount: 10\n};\nconst meshGradientFragmentShader = `#version 300 es\nprecision mediump float;\n\nuniform float u_time;\n\nuniform vec4 u_colors[${meshGradientMeta.maxColorCount}];\nuniform float u_colorsCount;\n\nuniform float u_distortion;\nuniform float u_swirl;\n\n${_shader_sizing_js__WEBPACK_IMPORTED_MODULE_0__.sizingVariablesDeclaration}\n\nout vec4 fragColor;\n\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declarePI}\n${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.declareRotate}\n\nvec2 getPosition(int i, float t) {\n  float a = float(i) * .37;\n  float b = .6 + mod(float(i), 3.) * .3;\n  float c = .8 + mod(float(i + 1), 4.) * 0.25;\n\n  float x = sin(t * b + a);\n  float y = cos(t * c + a * 1.5);\n\n  return .5 + .5 * vec2(x, y);\n}\n\nvoid main() {\n  vec2 shape_uv = v_objectUV;\n\n  shape_uv += .5;\n\n  float t = .5 * u_time;\n\n  float radius = smoothstep(0., 1., length(shape_uv - .5));\n  float center = 1. - radius;\n  for (float i = 1.; i <= 2.; i++) {\n    shape_uv.x += u_distortion * center / i * sin(t + i * .4 * smoothstep(.0, 1., shape_uv.y)) * cos(.2 * t + i * 2.4 * smoothstep(.0, 1., shape_uv.y));\n    shape_uv.y += u_distortion * center / i * cos(t + i * 2. * smoothstep(.0, 1., shape_uv.x));\n  }\n\n  vec2 uvRotated = shape_uv;\n  uvRotated -= vec2(.5);\n  float angle = 3. * u_swirl * radius;\n  uvRotated = rotate(uvRotated, -angle);\n  uvRotated += vec2(.5);\n\n  vec3 color = vec3(0.);\n  float opacity = 0.;\n  float totalWeight = 0.;\n\n  for (int i = 0; i < ${meshGradientMeta.maxColorCount}; i++) {\n    if (i >= int(u_colorsCount)) break;\n\n    vec2 pos = getPosition(i, t);\n    vec3 colorFraction = u_colors[i].rgb * u_colors[i].a;\n    float opacityFraction = u_colors[i].a;\n\n    float dist = 0.;\n    if (mod(float(i), 2.) > 1.) {\n      dist = length(shape_uv - pos);\n    } else {\n      dist = length(uvRotated - pos);\n    }\n\n    dist = pow(dist, 3.5);\n    float weight = 1. / (dist + 1e-3);\n    color += colorFraction * weight;\n    opacity += opacityFraction * weight;\n    totalWeight += weight;\n  }\n\n  color /= totalWeight;\n  opacity /= totalWeight;\n\n  ${_shader_utils_js__WEBPACK_IMPORTED_MODULE_1__.colorBandingFix}\n\n  fragColor = vec4(color, opacity);\n}\n`;\n\n//# sourceMappingURL=mesh-gradient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBhcGVyLWRlc2lnbitzaGFkZXJzQDAuMC4zOS9ub2RlX21vZHVsZXMvQHBhcGVyLWRlc2lnbi9zaGFkZXJzL2Rpc3Qvc2hhZGVycy9tZXNoLWdyYWRpZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUU7QUFDYztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQSxFQUFFLHlFQUEwQjs7QUFFNUI7O0FBRUEsRUFBRSx1REFBUztBQUNYLEVBQUUsMkRBQWE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsTUFBTSxpQ0FBaUM7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUksNkRBQWU7O0FBRW5CO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGFubWlcXFVuaXZlcnNpdHkgU3R1ZmZcXENvZGluZyBQcm9qZWN0c1xcdHVyYm9yZWFkXFxhcHBzXFx3ZWJcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEBwYXBlci1kZXNpZ24rc2hhZGVyc0AwLjAuMzlcXG5vZGVfbW9kdWxlc1xcQHBhcGVyLWRlc2lnblxcc2hhZGVyc1xcZGlzdFxcc2hhZGVyc1xcbWVzaC1ncmFkaWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogICAgICAgICAgICAgICAgICAgIFBhcGVyIFNoYWRlcnMgICAgICAgICAgICAgICAgICAgICpcbiAqICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlci1kZXNpZ24vc2hhZGVycyAgICAgICAqXG4gKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKi9cblxuaW1wb3J0IHsgc2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb24gfSBmcm9tIFwiLi4vc2hhZGVyLXNpemluZy5qc1wiO1xuaW1wb3J0IHsgZGVjbGFyZVBJLCBkZWNsYXJlUm90YXRlLCBjb2xvckJhbmRpbmdGaXggfSBmcm9tIFwiLi4vc2hhZGVyLXV0aWxzLmpzXCI7XG5jb25zdCBtZXNoR3JhZGllbnRNZXRhID0ge1xuICBtYXhDb2xvckNvdW50OiAxMFxufTtcbmNvbnN0IG1lc2hHcmFkaWVudEZyYWdtZW50U2hhZGVyID0gYCN2ZXJzaW9uIDMwMCBlc1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbnVuaWZvcm0gZmxvYXQgdV90aW1lO1xuXG51bmlmb3JtIHZlYzQgdV9jb2xvcnNbJHttZXNoR3JhZGllbnRNZXRhLm1heENvbG9yQ291bnR9XTtcbnVuaWZvcm0gZmxvYXQgdV9jb2xvcnNDb3VudDtcblxudW5pZm9ybSBmbG9hdCB1X2Rpc3RvcnRpb247XG51bmlmb3JtIGZsb2F0IHVfc3dpcmw7XG5cbiR7c2l6aW5nVmFyaWFibGVzRGVjbGFyYXRpb259XG5cbm91dCB2ZWM0IGZyYWdDb2xvcjtcblxuJHtkZWNsYXJlUEl9XG4ke2RlY2xhcmVSb3RhdGV9XG5cbnZlYzIgZ2V0UG9zaXRpb24oaW50IGksIGZsb2F0IHQpIHtcbiAgZmxvYXQgYSA9IGZsb2F0KGkpICogLjM3O1xuICBmbG9hdCBiID0gLjYgKyBtb2QoZmxvYXQoaSksIDMuKSAqIC4zO1xuICBmbG9hdCBjID0gLjggKyBtb2QoZmxvYXQoaSArIDEpLCA0LikgKiAwLjI1O1xuXG4gIGZsb2F0IHggPSBzaW4odCAqIGIgKyBhKTtcbiAgZmxvYXQgeSA9IGNvcyh0ICogYyArIGEgKiAxLjUpO1xuXG4gIHJldHVybiAuNSArIC41ICogdmVjMih4LCB5KTtcbn1cblxudm9pZCBtYWluKCkge1xuICB2ZWMyIHNoYXBlX3V2ID0gdl9vYmplY3RVVjtcblxuICBzaGFwZV91diArPSAuNTtcblxuICBmbG9hdCB0ID0gLjUgKiB1X3RpbWU7XG5cbiAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLiwgMS4sIGxlbmd0aChzaGFwZV91diAtIC41KSk7XG4gIGZsb2F0IGNlbnRlciA9IDEuIC0gcmFkaXVzO1xuICBmb3IgKGZsb2F0IGkgPSAxLjsgaSA8PSAyLjsgaSsrKSB7XG4gICAgc2hhcGVfdXYueCArPSB1X2Rpc3RvcnRpb24gKiBjZW50ZXIgLyBpICogc2luKHQgKyBpICogLjQgKiBzbW9vdGhzdGVwKC4wLCAxLiwgc2hhcGVfdXYueSkpICogY29zKC4yICogdCArIGkgKiAyLjQgKiBzbW9vdGhzdGVwKC4wLCAxLiwgc2hhcGVfdXYueSkpO1xuICAgIHNoYXBlX3V2LnkgKz0gdV9kaXN0b3J0aW9uICogY2VudGVyIC8gaSAqIGNvcyh0ICsgaSAqIDIuICogc21vb3Roc3RlcCguMCwgMS4sIHNoYXBlX3V2LngpKTtcbiAgfVxuXG4gIHZlYzIgdXZSb3RhdGVkID0gc2hhcGVfdXY7XG4gIHV2Um90YXRlZCAtPSB2ZWMyKC41KTtcbiAgZmxvYXQgYW5nbGUgPSAzLiAqIHVfc3dpcmwgKiByYWRpdXM7XG4gIHV2Um90YXRlZCA9IHJvdGF0ZSh1dlJvdGF0ZWQsIC1hbmdsZSk7XG4gIHV2Um90YXRlZCArPSB2ZWMyKC41KTtcblxuICB2ZWMzIGNvbG9yID0gdmVjMygwLik7XG4gIGZsb2F0IG9wYWNpdHkgPSAwLjtcbiAgZmxvYXQgdG90YWxXZWlnaHQgPSAwLjtcblxuICBmb3IgKGludCBpID0gMDsgaSA8ICR7bWVzaEdyYWRpZW50TWV0YS5tYXhDb2xvckNvdW50fTsgaSsrKSB7XG4gICAgaWYgKGkgPj0gaW50KHVfY29sb3JzQ291bnQpKSBicmVhaztcblxuICAgIHZlYzIgcG9zID0gZ2V0UG9zaXRpb24oaSwgdCk7XG4gICAgdmVjMyBjb2xvckZyYWN0aW9uID0gdV9jb2xvcnNbaV0ucmdiICogdV9jb2xvcnNbaV0uYTtcbiAgICBmbG9hdCBvcGFjaXR5RnJhY3Rpb24gPSB1X2NvbG9yc1tpXS5hO1xuXG4gICAgZmxvYXQgZGlzdCA9IDAuO1xuICAgIGlmIChtb2QoZmxvYXQoaSksIDIuKSA+IDEuKSB7XG4gICAgICBkaXN0ID0gbGVuZ3RoKHNoYXBlX3V2IC0gcG9zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzdCA9IGxlbmd0aCh1dlJvdGF0ZWQgLSBwb3MpO1xuICAgIH1cblxuICAgIGRpc3QgPSBwb3coZGlzdCwgMy41KTtcbiAgICBmbG9hdCB3ZWlnaHQgPSAxLiAvIChkaXN0ICsgMWUtMyk7XG4gICAgY29sb3IgKz0gY29sb3JGcmFjdGlvbiAqIHdlaWdodDtcbiAgICBvcGFjaXR5ICs9IG9wYWNpdHlGcmFjdGlvbiAqIHdlaWdodDtcbiAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7XG4gIH1cblxuICBjb2xvciAvPSB0b3RhbFdlaWdodDtcbiAgb3BhY2l0eSAvPSB0b3RhbFdlaWdodDtcblxuICAke2NvbG9yQmFuZGluZ0ZpeH1cblxuICBmcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCBvcGFjaXR5KTtcbn1cbmA7XG5leHBvcnQge1xuICBtZXNoR3JhZGllbnRGcmFnbWVudFNoYWRlcixcbiAgbWVzaEdyYWRpZW50TWV0YVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc2gtZ3JhZGllbnQuanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@paper-design+shaders@0.0.39/node_modules/@paper-design/shaders/dist/shaders/mesh-gradient.js\n");

/***/ })

};
;